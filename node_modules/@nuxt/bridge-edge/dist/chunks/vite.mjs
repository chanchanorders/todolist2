import { normalize, isAbsolute, resolve as resolve$1, join } from 'pathe';
import { logger, useNuxt, isIgnored } from '@nuxt/kit';
import { resolve, findExports, sanitizeFilePath } from 'mlly';
import { joinURL, withoutLeadingSlash, withTrailingSlash } from 'ufo';
import { d as distDir, i as isCSS, p as prepareManifests, a as pkgDir } from '../shared/bridge-edge.2026cf91.mjs';
import createVuePlugin from '@vitejs/plugin-vue2';
import { getPort } from 'get-port-please';
import { toNodeListener, createApp, defineEventHandler, defineLazyEventHandler, eventHandler, createError } from 'h3';
import defu, { defu as defu$1 } from 'defu';
import { pathToFileURL } from 'node:url';
import { ViteNodeServer } from 'vite-node/server';
import fse from 'fs-extra';
import { isFileServingAllowed } from 'vite';
import { normalizeViteManifest } from 'vue-bundle-renderer';
import { ExternalsDefaults, isExternal } from 'externality';
import escapeRE from 'escape-string-regexp';
import require$$0 from '@vitejs/plugin-legacy';
import MagicString from 'magic-string';
import createResolver from 'postcss-import-resolver';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

// CommonJS proxy to bypass jiti transforms from nuxt 2
// eslint-disable-next-line jsdoc/valid-types
/** @type {typeof import('vite')} */
var stubVite = {
  mergeConfig: function (...args) {
    return import('vite').then(m => m.mergeConfig.call(this, ...args))
  },
  createServer: function (...args) {
    return import('vite').then(m => m.createServer.call(this, ...args))
  },
  build: function (...args) {
    return import('vite').then(m => m.build.call(this, ...args))
  }
};

async function warmupViteServer(server, entries, isServer) {
  const warmedUrls = /* @__PURE__ */ new Set();
  const warmup = async (url) => {
    if (warmedUrls.has(url)) {
      return;
    }
    warmedUrls.add(url);
    try {
      await server.transformRequest(url, { ssr: isServer });
    } catch (e) {
      logger.debug("Warmup for %s failed with: %s", url, e);
    }
    const mod = await server.moduleGraph.getModuleByUrl(url, isServer);
    const deps = Array.from(mod?.importedModules || []);
    await Promise.all(deps.map((m) => warmup(m.url.replace("/@id/__x00__", "\0"))));
  };
  await Promise.all(entries.map((entry) => warmup(entry)));
}

function createIsExternal(viteServer, rootDir) {
  const externalOpts = {
    inline: [
      /virtual:/,
      /\.ts$/,
      ...ExternalsDefaults.inline || [],
      ...Array.isArray(viteServer.config.ssr.noExternal) ? viteServer.config.ssr.noExternal : []
    ],
    external: [
      ...viteServer.config.ssr.external || [],
      /node_modules/
    ],
    resolve: {
      type: "module",
      extensions: [".ts", ".js", ".json", ".vue", ".mjs", ".jsx", ".tsx", ".wasm"]
    }
  };
  return (id) => isExternal(id, rootDir, externalOpts);
}

function transpile(envs) {
  const nuxt = useNuxt();
  const transpile2 = [];
  for (let pattern of nuxt.options.build.transpile) {
    if (typeof pattern === "function") {
      const result = pattern(envs);
      if (result) {
        pattern = result;
      }
    }
    if (typeof pattern === "string") {
      transpile2.push(new RegExp(escapeRE(normalize(pattern))));
    } else if (pattern instanceof RegExp) {
      transpile2.push(pattern);
    }
  }
  return transpile2;
}

function viteNodePlugin(ctx) {
  const invalidates = /* @__PURE__ */ new Set();
  function markInvalidate(mod) {
    if (!mod.id) {
      return;
    }
    if (invalidates.has(mod.id)) {
      return;
    }
    invalidates.add(mod.id);
    markInvalidates(mod.importers);
  }
  function markInvalidates(mods) {
    if (!mods) {
      return;
    }
    for (const mod of mods) {
      markInvalidate(mod);
    }
  }
  return {
    name: "nuxt:vite-node-server",
    enforce: "post",
    configureServer(server) {
      function invalidateVirtualModules() {
        for (const [id, mod] of server.moduleGraph.idToModuleMap) {
          if (id.startsWith("virtual:")) {
            markInvalidate(mod);
          }
        }
        for (const plugin of ctx.nuxt.options.plugins) {
          markInvalidates(
            server.moduleGraph.getModulesByFile(
              typeof plugin === "string" ? plugin : plugin.src
            )
          );
        }
        for (const template of ctx.nuxt.options.build.templates) {
          markInvalidates(server.moduleGraph.getModulesByFile(template?.src));
        }
      }
      server.middlewares.use(
        "/__nuxt_vite_node__",
        toNodeListener(createViteNodeApp(ctx, invalidates))
      );
      ctx.nuxt.hook("app:templatesGenerated", () => {
        invalidateVirtualModules();
      });
      server.watcher.on("all", (event, file) => {
        markInvalidates(server.moduleGraph.getModulesByFile(normalize(file)));
        if (event === "add" || event === "unlink") {
          invalidateVirtualModules();
        }
      });
    }
  };
}
function getManifest(ctx) {
  const css = Array.from(
    ctx.ssrServer.moduleGraph.urlToModuleMap.keys()
  ).filter((i) => isCSS(i));
  const manifest = normalizeViteManifest({
    "@vite/client": {
      file: "@vite/client",
      css,
      module: true,
      isEntry: true
    },
    "entry.mjs": {
      file: "entry.mjs",
      isEntry: true,
      module: true,
      resourceType: "script"
    }
  });
  return manifest;
}
function createViteNodeApp(ctx, invalidates = /* @__PURE__ */ new Set()) {
  const app = createApp();
  app.use(
    "/manifest",
    defineEventHandler(() => {
      const manifest = getManifest(ctx);
      return manifest;
    })
  );
  app.use(
    "/invalidates",
    defineEventHandler(() => {
      const ids = Array.from(invalidates);
      invalidates.clear();
      return ids;
    })
  );
  app.use(
    "/module",
    defineLazyEventHandler(() => {
      const viteServer = ctx.ssrServer;
      const node = new ViteNodeServer(viteServer, {
        deps: {
          inline: [
            /\/(nuxt|nuxt3)\//,
            /^#/,
            ...transpile({ isServer: true, isDev: ctx.nuxt.options.dev })
          ]
        },
        transformMode: {
          ssr: [/.*/],
          web: []
        }
      });
      const isExternal = createIsExternal(viteServer, ctx.nuxt.options.rootDir);
      node.shouldExternalize = async (id) => {
        const result = await isExternal(id);
        if (result?.external) {
          return resolve(result.id, { url: ctx.nuxt.options.modulesDir });
        }
        return false;
      };
      return eventHandler(async (event) => {
        const moduleId = decodeURI(event.node.req.url).substring(1);
        if (moduleId === "/") {
          throw createError({ statusCode: 400 });
        }
        if (isAbsolute(moduleId) && !isFileServingAllowed(moduleId, viteServer)) {
          throw createError({
            statusCode: 403
            /* Restricted */
          });
        }
        const module = await node.fetchModule(moduleId).catch((err) => {
          const errorData = {
            code: "VITE_ERROR",
            id: moduleId,
            stack: "",
            ...err
          };
          throw createError({ data: errorData });
        });
        return module;
      });
    })
  );
  return app;
}
async function initViteNodeServer(ctx) {
  const viteNodeServerOptions = {
    baseURL: `${ctx.nuxt.options.devServer.url}__nuxt_vite_node__`,
    root: ctx.nuxt.options.srcDir,
    entryPath: resolve$1(ctx.nuxt.options.buildDir, "server.js"),
    base: ctx.ssrServer.config.base || "/_nuxt/"
  };
  process.env.NUXT_VITE_NODE_OPTIONS = JSON.stringify(viteNodeServerOptions);
  const serverResolvedPath = resolve$1(distDir, "runtime/vite/vite-node.mjs");
  const manifestResolvedPath = resolve$1(distDir, "runtime/vite/client.manifest.mjs");
  await fse.writeFile(
    resolve$1(ctx.nuxt.options.buildDir, "dist/server/server.mjs"),
    `export { default } from ${JSON.stringify(
      pathToFileURL(serverResolvedPath).href
    )}`
  );
  await fse.writeFile(
    resolve$1(ctx.nuxt.options.buildDir, "dist/server/client.manifest.mjs"),
    `export { default } from ${JSON.stringify(
      pathToFileURL(manifestResolvedPath).href
    )}`
  );
}

// CommonJS proxy to bypass jiti transforms from nuxt 2
/** @type {typeof import('@vitejs/plugin-legacy')['default'] } */
var stubLegacy = require$$0;

const PluginLegacy = /*@__PURE__*/getDefaultExportFromCjs(stubLegacy);

function devStyleSSRPlugin(options) {
  return {
    name: "nuxt:dev-style-ssr",
    apply: "serve",
    enforce: "post",
    transform(code, id) {
      if (!isCSS(id) || !code.includes("import.meta.hot")) {
        return;
      }
      let moduleId = id;
      if (moduleId.startsWith(options.srcDir)) {
        moduleId = moduleId.slice(options.srcDir.length);
      }
      const selector = joinURL(options.buildAssetsURL, moduleId);
      return code + `
document.querySelectorAll(\`link[href="${selector}"]\`).forEach(i=>i.remove())`;
    }
  };
}

const needsJsxProcessing = (id = "") => !id.includes("node_modules") && [".vue", ".jsx", ".tsx"].some((extension) => id.includes(extension));
function jsxPlugin() {
  return {
    name: "nuxt:jsx",
    transform(code, id) {
      if (!needsJsxProcessing(id)) {
        return null;
      }
      return {
        code: code.replace(/render\s*\(\s*\)\s*\{/g, "render(h){"),
        map: null
      };
    }
  };
}

async function buildClient(ctx) {
  const alias = {
    "#internal/nitro": resolve$1(ctx.nuxt.options.buildDir, "nitro.client.mjs")
  };
  for (const p of ctx.builder.plugins) {
    alias[p.name] = p.mode === "server" ? `defaultexport:${resolve$1(ctx.nuxt.options.buildDir, "empty.js")}` : `defaultexport:${p.src}`;
  }
  const clientConfig = await stubVite.mergeConfig(ctx.config, {
    base: ctx.nuxt.options.dev ? joinURL(ctx.nuxt.options.app.baseURL.replace(/^\.\//, "/") || "/", ctx.nuxt.options.app.buildAssetsDir) : "./",
    experimental: {
      renderBuiltUrl: (filename, { type, hostType }) => {
        if (hostType !== "js" || type === "asset") {
          return { relative: true };
        }
        return { runtime: `globalThis.__publicAssetsURL(${JSON.stringify(filename)})` };
      }
    },
    define: {
      "process.client": true,
      "process.server": false,
      "process.static": false,
      // use `process.client` instead. `process.browser` is deprecated
      "process.browser": true,
      "module.hot": false
    },
    cacheDir: resolve$1(ctx.nuxt.options.rootDir, "node_modules/.cache/vite/client"),
    resolve: {
      alias,
      dedupe: ["vue"]
    },
    build: {
      rollupOptions: {
        input: resolve$1(ctx.nuxt.options.buildDir, "client.js")
      },
      manifest: true,
      outDir: resolve$1(ctx.nuxt.options.buildDir, "dist/client")
    },
    plugins: [
      jsxPlugin(),
      createVuePlugin(ctx.config.vue),
      PluginLegacy(),
      devStyleSSRPlugin({
        srcDir: ctx.nuxt.options.srcDir,
        buildAssetsURL: joinURL(ctx.nuxt.options.app.baseURL, ctx.nuxt.options.app.buildAssetsDir)
      }),
      viteNodePlugin(ctx)
    ],
    appType: "custom",
    server: {
      middlewareMode: true
    }
  });
  if (!ctx.nuxt.options.dev) {
    clientConfig.server.hmr = false;
  }
  if (clientConfig.server && clientConfig.server.hmr !== false) {
    const hmrPortDefault = 24678;
    const hmrPort = await getPort({
      port: hmrPortDefault,
      ports: Array.from({ length: 20 }, (_, i) => hmrPortDefault + 1 + i)
    });
    clientConfig.server = defu(clientConfig.server, {
      https: ctx.nuxt.options.server.https,
      hmr: {
        protocol: ctx.nuxt.options.server.https ? "wss" : "ws",
        port: hmrPort
      }
    });
  }
  ctx.config.build.rollupOptions = defu(ctx.config.build.rollupOptions, {
    output: {
      // https://github.com/vitejs/vite/tree/main/packages/vite/src/node/build.ts#L464-L478
      assetFileNames: ctx.nuxt.options.dev ? void 0 : withoutLeadingSlash(join(ctx.nuxt.options.app.buildAssetsDir, "[name].[hash].[ext]")),
      chunkFileNames: ctx.nuxt.options.dev ? void 0 : withoutLeadingSlash(join(ctx.nuxt.options.app.buildAssetsDir, "[name].[hash].js")),
      entryFileNames: ctx.nuxt.options.dev ? "entry.js" : withoutLeadingSlash(join(ctx.nuxt.options.app.buildAssetsDir, "[name].[hash].js"))
    }
  });
  await ctx.nuxt.callHook("vite:extendConfig", clientConfig, { isClient: true, isServer: false });
  if (ctx.nuxt.options.dev) {
    const viteServer = await stubVite.createServer(clientConfig);
    ctx.clientServer = viteServer;
    await ctx.nuxt.callHook("vite:serverCreated", viteServer, { isClient: true, isServer: false });
    const transformHandler = viteServer.middlewares.stack.findIndex((m) => m.handle instanceof Function && m.handle.name === "viteTransformMiddleware");
    viteServer.middlewares.stack.splice(transformHandler, 0, {
      route: "",
      handle: (req, res, next) => {
        if (req._skip_transform) {
          req.url = joinURL("/__skip_vite", req.url);
        }
        next();
      }
    });
    const viteMiddleware = defineEventHandler(async (event) => {
      const originalURL = event.node.req.url;
      const viteRoutes = viteServer.middlewares.stack.map((m) => m.route).filter((r) => r.length > 1);
      if (!originalURL.startsWith(clientConfig.base) && !viteRoutes.some((route) => originalURL.startsWith(route))) {
        event.node.req._skip_transform = true;
      }
      await new Promise((resolve2, reject) => {
        viteServer.middlewares.handle(event.node.req, event.node.res, (err) => {
          event.node.req.url = originalURL;
          return err ? reject(err) : resolve2(null);
        });
      });
    });
    await ctx.nuxt.callHook("server:devHandler", viteMiddleware);
    ctx.nuxt.hook("close", async () => {
      await viteServer.close();
    });
  } else {
    const start = Date.now();
    await stubVite.build(clientConfig);
    logger.info(`Client built in ${Date.now() - start}ms`);
  }
  await prepareManifests(ctx);
}

const wpfs = {
  ...fse,
  join
};

async function buildServer(ctx) {
  const _env = process.env.NODE_ENV;
  process.env.NODE_ENV = "production";
  const vuePlugin = createVuePlugin(ctx.config.vue);
  process.env.NODE_ENV = _env;
  const alias = {};
  for (const p of ctx.builder.plugins) {
    alias[p.name] = p.mode === "client" ? `defaultexport:${resolve$1(ctx.nuxt.options.buildDir, "empty.js")}` : `defaultexport:${p.src}`;
  }
  const serverConfig = await stubVite.mergeConfig(ctx.config, {
    base: ctx.nuxt.options.dev ? joinURL(ctx.nuxt.options.app.baseURL, ctx.nuxt.options.app.buildAssetsDir) : void 0,
    experimental: {
      renderBuiltUrl: (filename, { type, hostType }) => {
        if (hostType !== "js") {
          return { relative: true };
        }
        switch (type) {
          case "public":
            return { runtime: `__publicAssetsURL(${JSON.stringify(filename)})` };
          case "asset": {
            const relativeFilename = filename.replace(withTrailingSlash(withoutLeadingSlash(ctx.nuxt.options.app.buildAssetsDir)), "");
            return { runtime: `__buildAssetsURL(${JSON.stringify(relativeFilename)})` };
          }
        }
      }
    },
    define: {
      "process.server": true,
      "process.client": false,
      "process.static": false,
      // use `process.client` instead. `process.browser` is deprecated
      "process.browser": false,
      "typeof window": '"undefined"',
      "typeof document": '"undefined"',
      "typeof navigator": '"undefined"',
      "typeof location": '"undefined"',
      "typeof XMLHttpRequest": '"undefined"'
    },
    cacheDir: resolve$1(ctx.nuxt.options.rootDir, "node_modules/.cache/vite/server"),
    resolve: {
      alias
    },
    ssr: {
      external: [
        "axios",
        "#internal/nitro",
        "#internal/nitro/utils"
      ],
      noExternal: [
        // TODO: Use externality for production (rollup) build
        /\/esm\/.*\.js$/,
        /\.(es|esm|esm-browser|esm-bundler).js$/,
        "#app",
        /nitropack\/(dist|src)/,
        ...ctx.nuxt.options.build.transpile.filter((i) => typeof i === "string")
      ]
    },
    build: {
      outDir: resolve$1(ctx.nuxt.options.buildDir, "dist/server"),
      ssr: ctx.nuxt.options.ssr ?? true,
      ssrManifest: true,
      rollupOptions: {
        external: ["#internal/nitro/utils", "#internal/nitro"],
        input: resolve$1(ctx.nuxt.options.buildDir, "server.js"),
        output: {
          entryFileNames: "server.mjs",
          chunkFileNames: "chunks/[name].mjs",
          generatedCode: { constBindings: true },
          format: "module"
        },
        onwarn(warning, rollupWarn) {
          if (!["UNUSED_EXTERNAL_IMPORT"].includes(warning.code)) {
            rollupWarn(warning);
          }
        }
      }
    },
    server: {
      // https://github.com/vitest-dev/vitest/issues/229#issuecomment-1002685027
      preTransformRequests: false,
      hmr: false
    },
    plugins: [
      jsxPlugin(),
      vuePlugin
    ]
  });
  await ctx.nuxt.callHook("vite:extendConfig", serverConfig, { isClient: false, isServer: true });
  const onBuild = () => ctx.nuxt.callHook("build:resources", wpfs);
  if (!ctx.nuxt.options.dev) {
    const start = Date.now();
    logger.info("Building server...");
    await stubVite.build(serverConfig);
    await onBuild();
    logger.success(`Server built in ${Date.now() - start}ms`);
    return;
  }
  if (!ctx.nuxt.options.ssr) {
    await onBuild();
    return;
  }
  const viteServer = await stubVite.createServer(serverConfig);
  ctx.ssrServer = viteServer;
  await ctx.nuxt.callHook("vite:serverCreated", viteServer, { isClient: false, isServer: true });
  ctx.nuxt.hook("close", () => viteServer.close());
  await viteServer.pluginContainer.buildStart({});
  if (ctx.config.devBundler !== "legacy") {
    await initViteNodeServer(ctx);
  } else {
    logger.info("Vite server using legacy server bundler...");
    await import('./dev-bundler.mjs').then((r) => r.initViteDevBundler(ctx, onBuild));
  }
}

const PREFIX = "defaultexport:";
const hasPrefix = (id = "") => id.startsWith(PREFIX);
const removePrefix = (id = "") => hasPrefix(id) ? id.substr(PREFIX.length) : id;
function defaultExportPlugin() {
  return {
    name: "nuxt:default-export",
    enforce: "pre",
    resolveId(id, importer) {
      if (hasPrefix(id)) {
        return id;
      }
      if (importer && hasPrefix(importer)) {
        return this.resolve(id, removePrefix(importer));
      }
      return null;
    },
    async load(id) {
      if (!hasPrefix(id)) {
        return null;
      }
      const code = await fse.readFile(removePrefix(id), "utf8");
      const s = new MagicString(code);
      const exports = findExports(code);
      if (!exports.find((i) => i.names.includes("default"))) {
        s.append("\n\nexport default () => {}");
      }
      return {
        code: s.toString(),
        map: s.generateMap({ source: removePrefix(id), includeContent: true })
      };
    }
  };
}

function replace(replacements) {
  return {
    name: "nuxt:replace",
    transform(code) {
      Object.entries(replacements).forEach(([key, value]) => {
        const escapedKey = key.replace(/\./g, "\\.");
        code = code.replace(new RegExp(escapedKey, "g"), value);
      });
      return {
        code,
        map: null
      };
    }
  };
}

function resolveCSSOptions(nuxt) {
  const css = {
    postcss: {
      plugins: []
    }
  };
  const plugins = defu$1(nuxt.options.build.postcss.plugins, {
    // https://github.com/postcss/postcss-import
    "postcss-import": {
      resolve: createResolver({
        alias: { ...nuxt.options.alias },
        modules: [
          nuxt.options.srcDir,
          nuxt.options.rootDir,
          ...nuxt.options.modulesDir
        ]
      })
    },
    // https://github.com/postcss/postcss-url
    "postcss-url": {},
    // https://github.com/csstools/postcss-preset-env
    "postcss-preset-env": nuxt.options.build.postcss.preset || {}
  });
  for (const name in plugins) {
    const opts = plugins[name];
    if (!opts) {
      continue;
    }
    const plugin = nuxt.resolver.requireModule(name);
    css.postcss.plugins.push(plugin(opts));
  }
  return css;
}

async function bundle(nuxt, builder) {
  for (const p of builder.plugins) {
    p.src = nuxt.resolver.resolvePath(resolve$1(nuxt.options.buildDir, p.src));
  }
  const ctx = {
    nuxt,
    builder,
    config: await stubVite.mergeConfig(
      {
        // defaults from packages/schema/src/config/vite
        root: nuxt.options.srcDir,
        mode: nuxt.options.dev ? "development" : "production",
        logLevel: "warn",
        publicDir: resolve$1(nuxt.options.rootDir, nuxt.options.srcDir, nuxt.options.dir.static),
        vue: {
          isProduction: !nuxt.options.dev,
          template: {
            compilerOptions: nuxt.options.vue.compilerOptions
          }
        },
        esbuild: {
          jsxFactory: "h",
          jsxFragment: "Fragment",
          tsconfigRaw: "{}"
        },
        clearScreen: false,
        define: {
          "process.dev": nuxt.options.dev,
          "process.static": nuxt.options.target === "static",
          "process.env.NODE_ENV": JSON.stringify(nuxt.options.dev ? "development" : "production"),
          "process.mode": JSON.stringify(nuxt.options.dev ? "development" : "production"),
          "process.target": JSON.stringify(nuxt.options.target)
        },
        resolve: {
          extensions: [".mjs", ".js", ".ts", ".jsx", ".tsx", ".json", ".vue"],
          alias: {
            ...nuxt.options.alias,
            "#build": nuxt.options.buildDir,
            ".nuxt": nuxt.options.buildDir,
            "/entry.mjs": resolve$1(nuxt.options.buildDir, "client.js"),
            "web-streams-polyfill/ponyfill/es2018": resolve$1(distDir, "runtime/vite/mock/web-streams-polyfill.mjs"),
            "whatwg-url": resolve$1(distDir, "runtime/vite/mock/whatwg-url.mjs"),
            // Cannot destructure property 'AbortController' of ..
            "abort-controller": resolve$1(distDir, "runtime/vite/mock/abort-controller.mjs")
          }
        },
        optimizeDeps: {
          exclude: [
            "ufo",
            "date-fns",
            "nanoid",
            "vue"
            // TODO(Anthony): waiting for Vite's fix https://github.com/vitejs/vite/issues/5688
            // ...nuxt.options.build.transpile.filter(i => typeof i === 'string'),
            // 'vue-demi'
          ]
        },
        css: resolveCSSOptions(nuxt),
        build: {
          assetsDir: withoutLeadingSlash(nuxt.options.app.buildAssetsDir),
          emptyOutDir: false,
          rollupOptions: {
            output: { sanitizeFileName: sanitizeFilePath }
          }
        },
        plugins: [
          replace({
            __webpack_public_path__: "globalThis.__webpack_public_path__"
          }),
          jsxPlugin(),
          defaultExportPlugin()
        ],
        server: {
          watch: {
            ignored: isIgnored
          },
          fs: {
            strict: true,
            allow: [
              pkgDir,
              nuxt.options.buildDir,
              nuxt.options.srcDir,
              nuxt.options.rootDir,
              ...nuxt.options.modulesDir
            ]
          }
        }
      },
      nuxt.options.vite
    )
  };
  if (!nuxt.options.dev) {
    ctx.config.server.watch = void 0;
    ctx.config.build.watch = void 0;
  }
  await ctx.nuxt.callHook("vite:extend", ctx);
  if (nuxt.options.dev) {
    ctx.nuxt.hook("vite:serverCreated", (server, env) => {
      ctx.nuxt.hook("app:templatesGenerated", () => {
        for (const [id, mod] of server.moduleGraph.idToModuleMap) {
          if (id.startsWith("virtual:")) {
            server.moduleGraph.invalidateModule(mod);
          }
        }
      });
      if (ctx.nuxt.options.vite.warmupEntry !== false && // https://github.com/nuxt/nuxt/issues/14898
      !(env.isServer && ctx.nuxt.options.vite.devBundler !== "legacy")) {
        const start = Date.now();
        warmupViteServer(server, ["/.nuxt/entry.mjs"], env.isServer).then(() => {
          logger.info(`Vite warmed up in ${Date.now() - start}ms`);
        }).catch(logger.error);
      }
    });
  }
  await buildClient(ctx);
  await buildServer(ctx);
}
class ViteBuilder {
  constructor(builder) {
    this.builder = builder;
    this.nuxt = builder.nuxt;
  }
  build() {
    return bundle(this.nuxt, this.builder);
  }
}

const vite = {
	__proto__: null,
	ViteBuilder: ViteBuilder
};

export { createIsExternal as c, vite as v };
