import { useNuxt, addPluginTemplate, tryImportModule, resolvePath, addTemplate, resolveAlias, addWebpackPlugin, addVitePlugin, addPlugin, extendWebpackConfig, resolveFiles, defineNuxtModule, logger, addComponent, addImportsSources, installModule, checkNuxtCompatibility } from '@nuxt/kit';
import { dynamicEventHandler, fromNodeMiddleware } from 'h3';
import fs, { existsSync, readdirSync, statSync, promises } from 'fs';
import { fileURLToPath, pathToFileURL } from 'url';
import fetch from 'node-fetch';
import fse from 'fs-extra';
import { withoutTrailingSlash, joinURL, stringifyQuery, withBase, parseURL, parseQuery, withTrailingSlash, withoutLeadingSlash } from 'ufo';
import { dirname, join as join$1, resolve, normalize, isAbsolute, relative, parse as parse$1 } from 'pathe';
import { createNitro, writeTypes, build, prepare, copyPublicAssets, prerender, createDevServer } from 'nitropack';
import { defu } from 'defu';
import { normalizeWebpackManifest, normalizeViteManifest } from 'vue-bundle-renderer';
import { createRequire } from 'module';
import { join } from 'path';
import { findStaticImports, resolveImports, findExports } from 'mlly';
import { genDynamicImport, genString } from 'knitwork';
import { generateTypes, resolveSchema } from 'untyped';
import MagicString from 'magic-string';
import { createUnplugin } from 'unplugin';
import crypto, { createHash } from 'crypto';
import { parse } from 'acorn';
import { walk } from 'estree-walker';
import { promisify } from 'util';
import enhancedResolve from 'enhanced-resolve';
import { defineUnimportPreset, createUnimport, toImports } from 'unimport';
import { camelCase } from 'scule';
import escapeRE from 'escape-string-regexp';

class AsyncLoadingPlugin {
  constructor(opts) {
    this.opts = opts;
    const _require = createRequire(import.meta.url);
    const TemplatePath = _require.resolve("webpack/lib/Template", { paths: [...this.opts.modulesDir] });
    this.Template = _require(TemplatePath);
  }
  apply(compiler) {
    compiler.hooks.compilation.tap("AsyncLoading", (compilation) => {
      const mainTemplate = compilation.mainTemplate;
      mainTemplate.hooks.requireEnsure.tap(
        "AsyncLoading",
        (_source, chunk, hash) => {
          const Template = this.Template;
          const chunkFilename = mainTemplate.outputOptions.chunkFilename;
          const chunkMaps = chunk.getChunkMaps();
          const insertMoreModules = [
            "var moreModules = chunk.modules, chunkIds = chunk.ids;",
            "for(var moduleId in moreModules) {",
            Template.indent(
              mainTemplate.renderAddModule(
                hash,
                chunk,
                "moduleId",
                "moreModules[moduleId]"
              )
            ),
            "}"
          ];
          return Template.asString([
            "// Async chunk loading for Nitro",
            "",
            "var installedChunkData = installedChunks[chunkId];",
            'if(installedChunkData !== 0) { // 0 means "already installed".',
            Template.indent([
              '// array of [resolve, reject, promise] means "currently loading"',
              "if(installedChunkData) {",
              Template.indent(["promises.push(installedChunkData[2]);"]),
              "} else {",
              Template.indent([
                "// load the chunk and return promise to it",
                "var promise = new Promise(function(resolve, reject) {",
                Template.indent([
                  "installedChunkData = installedChunks[chunkId] = [resolve, reject];",
                  "import(" + mainTemplate.getAssetPath(
                    JSON.stringify(`./${chunkFilename}`),
                    {
                      hash: `" + ${mainTemplate.renderCurrentHashCode(
                        hash
                      )} + "`,
                      hashWithLength: (length) => `" + ${mainTemplate.renderCurrentHashCode(
                        hash,
                        length
                      )} + "`,
                      chunk: {
                        id: '" + chunkId + "',
                        hash: `" + ${JSON.stringify(
                          chunkMaps.hash
                        )}[chunkId] + "`,
                        hashWithLength: (length) => {
                          const shortChunkHashMap = {};
                          for (const chunkId of Object.keys(chunkMaps.hash)) {
                            if (typeof chunkMaps.hash[chunkId] === "string") {
                              shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
                            }
                          }
                          return `" + ${JSON.stringify(
                            shortChunkHashMap
                          )}[chunkId] + "`;
                        },
                        contentHash: {
                          javascript: `" + ${JSON.stringify(
                            chunkMaps.contentHash.javascript
                          )}[chunkId] + "`
                        },
                        contentHashWithLength: {
                          javascript: (length) => {
                            const shortContentHashMap = {};
                            const contentHash = chunkMaps.contentHash.javascript;
                            for (const chunkId of Object.keys(contentHash)) {
                              if (typeof contentHash[chunkId] === "string") {
                                shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length);
                              }
                            }
                            return `" + ${JSON.stringify(
                              shortContentHashMap
                            )}[chunkId] + "`;
                          }
                        },
                        name: `" + (${JSON.stringify(
                          chunkMaps.name
                        )}[chunkId]||chunkId) + "`
                      },
                      contentHashType: "javascript"
                    }
                  ) + ").then(chunk => {",
                  Template.indent(
                    insertMoreModules.concat([
                      "var callbacks = [];",
                      "for(var i = 0; i < chunkIds.length; i++) {",
                      Template.indent([
                        "if(installedChunks[chunkIds[i]])",
                        Template.indent([
                          "callbacks = callbacks.concat(installedChunks[chunkIds[i]][0]);"
                        ]),
                        "installedChunks[chunkIds[i]] = 0;"
                      ]),
                      "}",
                      "for(i = 0; i < callbacks.length; i++)",
                      Template.indent("callbacks[i]();")
                    ])
                  ),
                  "});"
                ]),
                "});",
                "promises.push(installedChunkData[2] = promise);"
              ]),
              "}"
            ]),
            "}"
          ]);
        }
      );
    });
  }
}

let dir = dirname(fileURLToPath(import.meta.url));
while (dir !== "/" && !existsSync(join(dir, "package.json"))) {
  dir = dirname(dir);
}
const pkgDir = dir;
const distDir = join(pkgDir, "dist");

function readDirRecursively(dir) {
  return readdirSync(dir).reduce((files, file) => {
    const name = join$1(dir, file);
    const isDirectory2 = statSync(name).isDirectory();
    return isDirectory2 ? [...files, ...readDirRecursively(name)] : [...files, name];
  }, []);
}
async function isDirectory(path) {
  try {
    return (await promises.stat(path)).isDirectory();
  } catch (_err) {
    return false;
  }
}

async function setupNitroBridge() {
  const nuxt = useNuxt();
  if (!nuxt.options.dev && nuxt.options.target === "static" && !nuxt.options._prepare && !nuxt.options._generate && !nuxt.options._export && !nuxt.options._legacyGenerate) {
    throw new Error("[nitro] Please use `nuxt generate` for static target");
  }
  nuxt.options.app.buildAssetsDir = nuxt.options.app.buildAssetsDir || nuxt.options.app.assetsPath;
  nuxt.options.app.assetsPath = nuxt.options.app.buildAssetsDir;
  nuxt.options.app.baseURL = nuxt.options.app.baseURL || nuxt.options.app.basePath;
  nuxt.options.app.cdnURL = nuxt.options.app.cdnURL || "";
  const publicConfig = nuxt.options.publicRuntimeConfig;
  const appConfig = { ...publicConfig._app, ...publicConfig.app };
  delete publicConfig.app;
  delete publicConfig._app;
  nuxt.options.runtimeConfig = defu(nuxt.options.runtimeConfig, {
    ...publicConfig,
    ...nuxt.options.privateRuntimeConfig,
    public: publicConfig,
    app: appConfig
  });
  nuxt.options.build.loadingScreen = false;
  nuxt.options.build.indicator = false;
  if (nuxt.options.build.analyze === true) {
    const { rootDir } = nuxt.options;
    nuxt.options.build.analyze = {
      template: "treemap",
      projectRoot: rootDir,
      filename: join$1(rootDir, ".nuxt/stats", "{name}.html")
    };
  }
  const _nitroConfig = nuxt.options.nitro || {};
  const routes = Array.isArray(nuxt.options.generate.routes) ? nuxt.options.generate.routes : [];
  const nitroConfig = defu(_nitroConfig, {
    rootDir: resolve(nuxt.options.rootDir),
    srcDir: resolve(nuxt.options.srcDir, "server"),
    dev: nuxt.options.dev,
    buildDir: resolve(nuxt.options.buildDir),
    scanDirs: nuxt.options._layers.map((layer) => join$1(layer.config.srcDir, "server")),
    renderer: resolve(distDir, "runtime/nitro/renderer"),
    errorHandler: resolve(distDir, "runtime/nitro/error"),
    nodeModulesDirs: nuxt.options.modulesDir,
    handlers: [],
    devHandlers: [],
    baseURL: nuxt.options.app.baseURL || "/",
    virtual: {},
    runtimeConfig: {
      ...nuxt.options.runtimeConfig,
      nitro: {
        envPrefix: "NUXT_",
        ...nuxt.options.runtimeConfig.nitro
      }
    },
    typescript: {
      generateTsConfig: false
    },
    publicAssets: [
      {
        baseURL: nuxt.options.bridge.vite ? "/" : nuxt.options.app.buildAssetsDir,
        dir: resolve(nuxt.options.buildDir, "dist/client")
      },
      ...nuxt.options._layers.map((layer) => join$1(layer.config.srcDir, layer.config.dir.static)).filter((dir) => existsSync(dir)).map((dir) => ({ dir }))
    ],
    prerender: {
      crawlLinks: nuxt.options._generate ? nuxt.options.generate.crawler : false,
      routes: [].concat(nuxt.options._generate ? ["/", ...routes] : []).concat(nuxt.options.ssr === false ? ["/", "/200", "/404"] : [])
    },
    externals: {
      inline: [
        ...nuxt.options.dev ? [] : ["vue", "@vue/", "@nuxt/", normalize(nuxt.options.buildDir)],
        "@nuxt/bridge/dist",
        "@nuxt/bridge-edge/dist"
      ]
    },
    alias: {
      // Vue 2 mocks
      encoding: "unenv/runtime/mock/proxy",
      he: "unenv/runtime/mock/proxy",
      resolve: "unenv/runtime/mock/proxy",
      "source-map": "unenv/runtime/mock/proxy",
      "lodash.template": "unenv/runtime/mock/proxy",
      "serialize-javascript": "unenv/runtime/mock/proxy",
      // Renderer
      "#vue-renderer": resolve(distDir, "runtime/nitro/vue2"),
      "#vue2-server-renderer": "vue-server-renderer/" + (nuxt.options.dev ? "build.dev.js" : "build.prod.js"),
      // Paths
      "#paths": resolve(distDir, "runtime/nitro/paths"),
      // Nuxt aliases
      ...nuxt.options.alias
    },
    replace: {
      "process.env.NUXT_NO_SSR": nuxt.options.ssr === false
    },
    rollupConfig: {
      plugins: []
    }
  });
  if (!nuxt.options.ssr) {
    nitroConfig.virtual["#build/dist/server/server.mjs"] = "export default () => {}";
  }
  delete nitroConfig.alias["#build"];
  if (nuxt.options.generate.routes instanceof Function && !nuxt.options.dev && !nuxt.options._prepare) {
    console.warn("It is recommended to migrate the `generate.routes` function to the `nitro:config` hook instead. See https://github.com/nuxt/bridge/pull/475.");
    nitroConfig.prerender.routes.push(...await nuxt.options.generate.routes() || []);
  }
  await nuxt.callHook("nitro:config", nitroConfig);
  const nitro = await createNitro(nitroConfig);
  nuxt._nitro = nitro;
  await nuxt.callHook("nitro:init", nitro);
  nitro.vfs = nuxt.vfs = nitro.vfs || nuxt.vfs || {};
  nuxt.hook("close", () => nitro.hooks.callHook("close"));
  async function updateViteBase() {
    const clientDist = resolve(nuxt.options.buildDir, "dist/client");
    const publicDir = join$1(nuxt.options.srcDir, nuxt.options.dir.static);
    let publicFiles = [];
    if (await isDirectory(publicDir)) {
      publicFiles = readDirRecursively(publicDir).map((r) => r.replace(publicDir, ""));
      for (const file of publicFiles) {
        try {
          fse.rmSync(join$1(clientDist, file));
        } catch {
        }
      }
    }
    if (await isDirectory(clientDist)) {
      const nestedAssetsPath = withoutTrailingSlash(join$1(clientDist, nuxt.options.app.buildAssetsDir));
      if (await isDirectory(nestedAssetsPath)) {
        await fse.copy(nestedAssetsPath, clientDist, { recursive: true });
        await fse.remove(nestedAssetsPath);
      }
    }
  }
  nuxt.hook("generate:before", updateViteBase);
  nuxt.options.extensions.push("ts");
  nuxt.hook("webpack:config", (webpackConfigs) => {
    const serverConfig = webpackConfigs.find((config) => config.name === "server");
    if (serverConfig) {
      serverConfig.devtool = false;
    }
  });
  nuxt.hook("webpack:config", (webpackConfigs) => {
    const serverConfig = webpackConfigs.find((config) => config.name === "server");
    if (serverConfig) {
      serverConfig.plugins = serverConfig.plugins || [];
      serverConfig.plugins.push(new AsyncLoadingPlugin({
        modulesDir: nuxt.options.modulesDir
      }));
    }
  });
  addPluginTemplate({
    filename: "nitro-bridge.client.mjs",
    src: resolve(distDir, "runtime/nitro-bridge.client.mjs")
  });
  addPluginTemplate({
    filename: "nitro-bridge.server.mjs",
    src: resolve(distDir, "runtime/nitro-bridge.server.mjs")
  });
  nuxt.hook("webpack:config", (configs) => {
    for (const config of configs) {
      if (Array.isArray(config.resolve.alias)) {
        return;
      }
      config.resolve.alias.ufo = "ufo/dist/index.mjs";
      config.resolve.alias.ofetch = "ofetch/dist/index.mjs";
      config.resolve.alias.ohmyfetch = "ohmyfetch/dist/index.mjs";
    }
  });
  nuxt.hook("build:compiled", async ({ name }) => {
    if (nuxt.options._prepare) {
      return;
    }
    if (name === "server") {
      const jsServerEntry = resolve(nuxt.options.buildDir, "dist/server/server.js");
      await promises.writeFile(jsServerEntry.replace(/.js$/, ".cjs"), 'module.exports = require("./server.js")', "utf8");
      await promises.writeFile(jsServerEntry.replace(/.js$/, ".mjs"), 'export { default } from "./server.cjs"', "utf8");
    } else if (name === "client") {
      const manifest = await promises.readFile(resolve(nuxt.options.buildDir, "dist/server/client.manifest.json"), "utf8");
      await promises.writeFile(resolve(nuxt.options.buildDir, "dist/server/client.manifest.mjs"), "export default " + JSON.stringify(normalizeWebpackManifest(JSON.parse(manifest)), null, 2), "utf8");
    }
  });
  const devMiddlewareHandler = dynamicEventHandler();
  nitro.options.devHandlers.unshift({ handler: devMiddlewareHandler });
  const { handlers, devHandlers } = await resolveHandlers(nuxt);
  nitro.options.handlers.push(...handlers);
  nitro.options.devHandlers.push(...devHandlers);
  nitro.options.handlers.unshift({
    route: "/__nuxt_error",
    lazy: true,
    handler: resolve(distDir, "runtime/nitro/renderer")
  });
  if (nuxt.server) {
    nuxt.server.__closed = true;
    nuxt.server = createNuxt2DevServer(nitro);
    nuxt.hook("build:resources", () => {
      nuxt.server.reload();
    });
  }
  nuxt.hook("prepare:types", (opts) => {
    opts.references.push({ path: resolve(nuxt.options.buildDir, "types/nitro.d.ts") });
  });
  nuxt.hook("build:done", async () => {
    await writeTypes(nitro);
  });
  nuxt.options.build._minifyServer = false;
  nuxt.options.build.standalone = false;
  const waitUntilCompile = new Promise((resolve2) => nitro.hooks.hook("compiled", () => resolve2()));
  nuxt.hook("build:done", async () => {
    if (nuxt.options._prepare) {
      return;
    }
    await writeDocumentTemplate(nuxt);
    await nuxt.callHook("nitro:build:before", nitro);
    if (nuxt.options.dev) {
      await build(nitro);
      await waitUntilCompile;
    } else {
      await prepare(nitro);
      await copyPublicAssets(nitro);
      if (nuxt.options._export || nuxt.options._legacyGenerate) {
        return;
      }
      const useClassicGeneration = process.argv.includes("--classic") || nuxt.options.bridge.nitroGenerator === false;
      if (useClassicGeneration && nuxt.options._generate) {
        const { Generator } = await tryImportModule("@nuxt/generator-edge") || await tryImportModule("@nuxt/generator");
        const generator = new Generator(nuxt);
        await generator.generate({ build: false });
        return;
      }
      await prerender(nitro);
      if (!nuxt.options._generate) {
        await build(nitro);
      } else {
        const distDir2 = resolve(nuxt.options.rootDir, "dist");
        if (!existsSync(distDir2)) {
          await promises.symlink(nitro.options.output.publicDir, distDir2, "junction").catch(() => {
          });
        }
      }
    }
  });
  if (!nuxt.options.dev && nuxt.options._generate) {
    const routes2 = /* @__PURE__ */ new Set();
    nuxt.hook("build:extendRoutes", (pages) => {
      routes2.clear();
      for (const path of nitro.options.prerender?.routes || []) {
        routes2.add(path);
      }
      const processPages = (pages2, currentPath = "/") => {
        for (const page of pages2) {
          if (page.path.includes(":")) {
            continue;
          }
          const path = joinURL(currentPath, page.path);
          routes2.add(path);
          if (page.children) {
            processPages(page.children, path);
          }
        }
      };
      processPages(pages);
    });
    nuxt.hook("nitro:build:before", (nitro2) => {
      nitro2.options.prerender.routes = [...routes2];
    });
  }
  if (nuxt.options.dev) {
    nuxt.hook("build:compile", ({ compiler }) => {
      compiler.outputFileSystem = { ...fse, join: join$1 };
    });
    nuxt.hook("server:devHandler", (h) => {
      devMiddlewareHandler.set(h);
    });
  }
  nuxt.options.generate.dir = nitro.options.output.publicDir;
  nuxt.options.generate.manifest = false;
  nuxt.hook("generate:cache:ignore", (ignore) => {
    ignore.push(nitro.options.output.dir);
    ignore.push(nitro.options.output.serverDir);
    if (nitro.options.output.publicDir) {
      ignore.push(nitro.options.output.publicDir);
    }
  });
  nuxt.hook("generate:before", async () => {
    await nuxt.server?.close();
  });
  nuxt.hook("generate:extendRoutes", async () => {
    nuxt.server = await createNuxt2Prerenderer(nitro);
    await nuxt.server.listen();
  });
  nuxt.hook("generate:done", async () => {
    await nuxt.server.close();
    await build(nitro);
  });
}
function createNuxt2DevServer(nitro) {
  const server = createDevServer(nitro);
  const listeners = [];
  async function listen(port) {
    const listener = await server.listen(port, {
      showURL: false,
      isProd: true
    });
    listeners.push(listener);
    return listener;
  }
  async function renderRoute(route = "/", renderContext = {}) {
    const [listener] = listeners;
    if (!listener) {
      throw new Error("There is no server listener to call `server.renderRoute()`");
    }
    const res = await fetch(joinURL(listener.url, route), {
      headers: { "nuxt-render-context": stringifyQuery(renderContext) }
    });
    const html = await res.text();
    if (!res.ok) {
      return { html, error: res.statusText };
    }
    return { html };
  }
  return {
    ...server,
    listeners,
    renderRoute,
    listen,
    serverMiddlewarePaths() {
      return [];
    },
    ready() {
    }
  };
}
async function createNuxt2Prerenderer(nitro) {
  const nitroRenderer = await createNitro({
    ...nitro.options._config,
    rootDir: nitro.options.rootDir,
    logLevel: 0,
    preset: "nitro-prerender"
  });
  await build(nitroRenderer);
  const serverEntrypoint = resolve(nitroRenderer.options.output.serverDir, "index.mjs");
  const { localFetch } = await import(pathToFileURL(serverEntrypoint).href);
  async function renderRoute(route = "/", renderContext = {}) {
    const res = await localFetch(withBase(route, nitro.options.baseURL), {
      headers: {
        "nuxt-render-context": stringifyQuery(renderContext)
      }
    });
    const html = await res.text();
    if (!res.ok) {
      return { html, error: res.statusText };
    }
    return { html };
  }
  return {
    ...createNuxt2DevServer(nitroRenderer),
    renderRoute
  };
}
async function resolveHandlers(nuxt) {
  const handlers = [...nuxt.options.serverHandlers || []];
  const devHandlers = [...nuxt.options.devServerHandlers || []];
  for (let m of nuxt.options.serverMiddleware) {
    if (typeof m === "string" || typeof m === "function") {
      m = { handler: m };
    }
    const route = m.path || m.route || "/";
    const handler = m.handler || m.handle;
    if (typeof handler !== "string" || typeof route !== "string") {
      devHandlers.push({ route, handler });
    } else {
      delete m.handler;
      delete m.path;
      handlers.push({
        ...m,
        route,
        handler: await resolvePath(handler)
      });
    }
  }
  return {
    handlers,
    devHandlers
  };
}
async function writeDocumentTemplate(nuxt) {
  const src = nuxt.options.appTemplatePath || resolve(nuxt.options.buildDir, "views/app.template.html");
  const dst = resolve(nuxt.options.buildDir, "views/document.template.mjs");
  const contents = nuxt.vfs[src] || await promises.readFile(src, "utf-8").catch(() => "");
  if (contents) {
    const compiled = `export default (params) => \`${contents.replace(/{{ (\w+) }}/g, "${params.$1}")}\``;
    await promises.mkdir(dirname(dst), { recursive: true });
    await promises.writeFile(dst, compiled, "utf8");
  }
}

const componentsTypeTemplate = {
  filename: "types/components.d.ts",
  getContents: ({ options }) => {
    const typesDir = join$1(options.buildDir, "types");
    return `// Generated by components discovery
declare module 'vue' {
  export interface GlobalComponents {
${options.components.map((c) => `    '${c.pascalName}': typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(typesDir, c.filePath) : c.filePath, { wrapper: false })}['${c.export}']`).join(",\n")}
${options.components.map((c) => `    'Lazy${c.pascalName}': typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(typesDir, c.filePath) : c.filePath, { wrapper: false })}['${c.export}']`).join(",\n")}
  }
}
${options.components.map((c) => `export const ${c.pascalName}: typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(typesDir, c.filePath) : c.filePath, { wrapper: false })}['${c.export}']`).join("\n")}
${options.components.map((c) => `export const Lazy${c.pascalName}: typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(typesDir, c.filePath) : c.filePath, { wrapper: false })}['${c.export}']`).join("\n")}
export const componentNames: string[]
`;
  }
};
const middlewareTypeTemplate = {
  filename: "types/middleware.d.ts",
  getContents: ({ app }) => {
    const middleware = app.templateVars.middleware;
    return [
      "import type { Nuxt2Context } from '@nuxt/bridge-schema'",
      "import type { ComponentOptions } from 'vue'",
      `export type MiddlewareKey = ${middleware.map((mw) => genString(mw.name)).join(" | ") || "string"}`,
      "declare module 'vue/types/options' {",
      "  export type Middleware = MiddlewareKey | ((ctx: Nuxt2Context, cb: Function) => Promise<void> | void)",
      "  interface ComponentOptions<V extends Vue> {",
      "    middleware?: Middleware | Middleware[]",
      "  }",
      "}"
    ].join("\n");
  }
};
const adHocModules = ["router", "pages", "auto-imports", "meta", "components"];
const schemaTemplate = {
  filename: "types/schema.d.ts",
  getContents: async ({ nuxt }) => {
    const moduleInfo = nuxt.options._installedModules.map((m) => ({
      ...m.meta || {},
      importName: m.entryPath || m.meta?.name
    })).filter((m) => m.configKey && m.name && !adHocModules.includes(m.name));
    return [
      "import { NuxtModule } from '@nuxt/schema'",
      "declare module '@nuxt/schema' {",
      "  interface NuxtConfig {",
      ...moduleInfo.filter(Boolean).map(
        (meta) => `    [${genString(meta.configKey)}]?: typeof ${genDynamicImport(meta.importName, { wrapper: false })}.default extends NuxtModule<infer O> ? Partial<O> : Record<string, any>`
      ),
      "  }",
      generateTypes(
        await resolveSchema(nuxt.options.runtimeConfig),
        {
          interfaceName: "RuntimeConfig",
          addExport: false,
          addDefaults: false,
          allowExtraKeys: false,
          indentation: 2
        }
      ),
      "}"
    ].join("\n");
  }
};

const VueCompat = createUnplugin((opts) => {
  return {
    name: "nuxt-legacy-vue-transform",
    enforce: "post",
    transformInclude(id) {
      if (id.includes("vue2-bridge")) {
        return false;
      }
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const query = parseQuery(search);
      if (pathname.endsWith(".vue") && (query.type === "script" || !search)) {
        return true;
      }
      if (pathname.match(/\.((c|m)?j|t)sx?/g)) {
        return true;
      }
    },
    transform(code, id) {
      if (id.includes("vue2-bridge")) {
        return;
      }
      const s = new MagicString(code);
      const imports = findStaticImports(code).filter((i) => i.type === "static" && vueAliases.includes(i.specifier));
      for (const i of imports) {
        s.overwrite(i.start, i.end, i.code.replace(`"${i.specifier}"`, `"${opts.src}"`).replace(`'${i.specifier}'`, `'${opts.src}'`));
      }
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap({ source: id, includeContent: true })
        };
      }
    }
  };
});
const vueAliases = [
  // vue 3 helper packages
  "@vue/shared",
  "@vue/reactivity",
  "@vue/runtime-core",
  "@vue/runtime-dom"
];

async function setupAppBridge(_options) {
  const nuxt = useNuxt();
  nuxt.options.alias["#app"] = resolve(distDir, "runtime/index");
  nuxt.options.alias["nuxt3/app"] = nuxt.options.alias["#app"];
  nuxt.options.alias["nuxt/app"] = nuxt.options.alias["#app"];
  nuxt.options.alias["#build"] = nuxt.options.buildDir;
  nuxt.options.build.transpile.push(resolve(distDir, "runtime").replace("dist", "src"));
  nuxt.options.build.transpile.push(normalize(nuxt.options.buildDir));
  if (nuxt.options._prepare) {
    nuxt.hook("builder:prepared", (builder) => {
      builder.bundleBuilder.build = () => Promise.resolve(builder.bundleBuilder);
    });
  }
  nuxt.hook("builder:prepared", (builder) => {
    nuxt.hook("build:done", () => {
      for (const name of ["app", "files", "custom"]) {
        builder.watchers[name]?.on("all", (event, path) => nuxt.callHook("builder:watch", event, path));
      }
    });
    nuxt.hook("builder:generateApp", () => builder.generateRoutesAndFiles());
  });
  nuxt.options.build.transpile.push("vuex");
  nuxt.options.build.transpile.push("h3", "iron-webcrypto", "ohash", "ofetch", "unenv");
  nuxt.options.build.transpile.push("unhead");
  nuxt.options.fetch.server = false;
  nuxt.options.fetch.client = false;
  const components = [];
  nuxt.hook("components:extend", (registeredComponents) => {
    components.push(...registeredComponents);
  });
  addTemplate({
    ...componentsTypeTemplate,
    options: { components, buildDir: nuxt.options.buildDir }
  });
  addTemplate(middlewareTypeTemplate);
  nuxt.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, "types/components.d.ts") });
    references.push({ path: resolve(nuxt.options.buildDir, "types/middleware.d.ts") });
  });
  nuxt.hook("modules:done", async (container) => {
    nuxt.options._installedModules = await Promise.all(Object.values(container.requiredModules).map(async (m) => ({
      meta: await m.handler.getMeta?.(),
      entryPath: resolveAlias(m.src, nuxt.options.alias)
    })));
    addTemplate(schemaTemplate);
  });
  nuxt.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, "types/schema.d.ts") });
  });
  addTemplate({
    filename: "composition-globals.mjs",
    getContents: () => {
      const globals = {
        // useFetch
        isFullStatic: !nuxt.options.dev && !nuxt.options._legacyGenerate && nuxt.options.target === "static" && nuxt.options.render?.ssr
      };
      const contents = Object.entries(globals).map(([key, value]) => `export const ${key} = ${JSON.stringify(value)}`).join("\n");
      return contents;
    }
  });
  const { dst: vueCompat } = addTemplate({ src: resolve(distDir, "runtime/vue2-bridge.mjs") });
  addWebpackPlugin(VueCompat.webpack({ src: vueCompat }));
  addVitePlugin(VueCompat.vite({ src: vueCompat }));
  nuxt.hook("prepare:types", ({ tsConfig }) => {
    tsConfig.vueCompilerOptions = {
      target: 2.7
    };
  });
  if (nuxt.options.globalName !== "nuxt") {
    throw new Error("Custom global name is not supported by @nuxt/bridge.");
  }
  nuxt.options.alias.defu = await resolveImports("defu", { conditions: ["import"] });
  nuxt.hook("webpack:config", (configs) => {
    for (const config of configs.filter((c) => c.module)) {
      const jsRule = config.module.rules.find((rule) => rule.test instanceof RegExp && rule.test.test("index.mjs"));
      jsRule.type = "javascript/auto";
      config.module.rules.unshift({
        test: /\.mjs$/,
        type: "javascript/auto",
        include: [/node_modules/]
      });
    }
  });
  nuxt.hook("modules:done", () => {
    nuxt.options.plugins.unshift({ src: resolve(distDir, "runtime/config.plugin.mjs") });
  });
  addPlugin({
    src: resolve(distDir, "runtime/error.plugin.server.mjs"),
    mode: "server"
  });
}

function createKey(source, method = "base64") {
  const hash = crypto.createHash("md5");
  hash.update(source);
  return hash.digest(method).toString();
}
const keyedFunctions = /(useStatic|shallowSsrRef|ssrPromise|ssrRef|reqSsrRef|useAsync)/;
const KeyPlugin = createUnplugin(() => {
  return {
    name: "nuxt-legacy-capi-key-transform",
    enforce: "pre",
    transformInclude(id) {
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const query = parseQuery(search);
      if (id.includes("node_modules")) {
        return false;
      }
      if (pathname.endsWith(".vue") && (query.type === "script" || !search)) {
        return true;
      }
      if (pathname.match(/\.((c|m)?j|t)sx?/g)) {
        return true;
      }
    },
    transform(code, id) {
      if (!keyedFunctions.test(code)) {
        return null;
      }
      try {
        const { 0: script = code, index: codeIndex = 0 } = code.match(/(?<=<script[^>]*>)[\S\s.]*?(?=<\/script>)/) || [];
        const ast = parse(script, { ecmaVersion: 2020, sourceType: "module" });
        const s = new MagicString(code);
        walk(ast, {
          enter(node) {
            const { end } = node;
            const { callee, arguments: args = [] } = node;
            if (callee?.type === "Identifier" || callee?.property?.type === "Identifier") {
              let method = "base64";
              switch (callee.name || callee.property?.name) {
                case "useStatic":
                  if (args.length > 2) {
                    return;
                  }
                  if (args.length === 2) {
                    s.prependLeft(codeIndex + end - 1, ", undefined");
                  }
                  method = "hex";
                  break;
                case "shallowSsrRef":
                case "ssrPromise":
                case "ssrRef":
                case "reqSsrRef":
                case "useAsync":
                  if (args.length > 1) {
                    return;
                  }
                  break;
                default:
                  return;
              }
              s.appendLeft(
                codeIndex + end - 1,
                ", '" + createKey(`${id}-${end}`, method) + "'"
              );
            }
          }
        });
        return s.toString();
      } catch {
      }
    }
  };
});

function setupCAPIBridge(options) {
  const nuxt = useNuxt();
  if (nuxt.options.buildModules.find((m) => m === "@nuxtjs/composition-api" || m === "@nuxtjs/composition-api/module")) {
    throw new Error("Please remove `@nuxtjs/composition-api` from `buildModules` to avoid conflict with bridge.");
  }
  const capiPluginPath = resolve(distDir, "runtime/capi.plugin.mjs");
  addPluginTemplate({ filename: "capi.plugin.mjs", src: capiPluginPath });
  const appPlugin = addPluginTemplate(resolve(distDir, "runtime/app.plugin.mjs"));
  nuxt.hook("modules:done", () => {
    nuxt.options.plugins.unshift(appPlugin);
  });
  nuxt.options.build.transpile.push("vue-router");
  if (options.legacy === false) {
    return;
  }
  nuxt.options.alias["@nuxtjs/composition-api"] = resolve(distDir, "runtime/capi.legacy");
  nuxt.options.build.transpile.push("@nuxtjs/composition-api");
  addVitePlugin(KeyPlugin.vite());
  addWebpackPlugin(KeyPlugin.webpack());
}

const DEFAULTS = {
  fileSystem: new enhancedResolve.CachedInputFileSystem(fs, 4e3),
  extensions: [".ts", ".tsx", ".mjs", ".cjs", ".js", ".jsx", ".json", ".vue"]
};
const createResolver = (resolveOptions) => {
  const options = defu(resolveOptions, DEFAULTS);
  const resolver = enhancedResolve.ResolverFactory.createResolver(options);
  const root = options.roots?.[0] || ".";
  const promisifiedResolve = promisify(resolver.resolve.bind(resolver));
  const resolve = (id, importer) => promisifiedResolve({}, importer || root, id, {});
  return { resolve, resolver };
};
class EnhancedResolverPlugin {
  constructor(options) {
    this.resolver = createResolver(options);
  }
  apply(defaultResolver) {
    const enhancedResolver = this.resolver;
    defaultResolver.getHook("resolve").tapPromise("EnhancedResolverPlugin", async (request) => {
      const id = request.request;
      if (!id || !defaultResolver.isModule(id)) {
        return;
      }
      if (id.includes("@babel/")) {
        return;
      }
      const importer = request.context?.issuer;
      try {
        const result = await enhancedResolver.resolve(id, importer);
        if (!result) {
          return;
        }
        request.path = result;
        return request;
      } catch {
      }
    });
  }
}
function setupBetterResolve() {
  const nuxt = useNuxt();
  extendWebpackConfig((config) => {
    const isServer = config.name === "server";
    config.resolve = config.resolve || {};
    config.resolve.plugins = config.resolve.plugins || [];
    config.resolve.plugins.push(new EnhancedResolverPlugin({
      conditionNames: ["import", ...isServer ? ["node"] : []],
      mainFields: ["module", ...isServer ? [] : ["browser"], "main"],
      alias: config.resolve.alias,
      modules: config.resolve.modules,
      plugins: config.resolve.plugins,
      roots: config.resolve.roots || [nuxt.options.rootDir]
    }));
  });
}

const NODE_MODULES_RE = /[\\/]node_modules[\\/]/;
const IMPORTS_RE = /(['"])#imports\1/;
const TransformPlugin = createUnplugin(({ ctx, options }) => {
  return {
    name: "nuxt:imports-transform",
    enforce: "post",
    transformInclude(id) {
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const { type, macro } = parseQuery(search);
      if (options.transform?.include?.some((pattern) => pattern.test(id))) {
        return true;
      }
      if (options.transform?.exclude?.some((pattern) => pattern.test(id))) {
        return false;
      }
      if (pathname.endsWith(".vue") && (type === "template" || type === "script" || macro || !search)) {
        return true;
      }
      if (pathname.match(/\.((c|m)?j|t)sx?$/g)) {
        return true;
      }
    },
    async transform(_code, id) {
      id = normalize(id);
      const isNodeModule = NODE_MODULES_RE.test(id) && !options.transform?.include?.some((pattern) => pattern.test(id));
      if (isNodeModule && !IMPORTS_RE.test(_code)) {
        return;
      }
      const { code, s } = await ctx.injectImports(_code, id, { autoImport: options.autoImport && !isNodeModule });
      if (code === _code) {
        return;
      }
      return {
        code,
        map: s.generateMap({ source: id, includeContent: true })
      };
    }
  };
});

const commonPresets = [
  // #head
  defineUnimportPreset({
    from: "#head",
    imports: [
      "useMeta"
    ]
  }),
  // vue-demi (mocked)
  defineUnimportPreset({
    from: "#app",
    imports: [
      "isVue2",
      "isVue3"
    ]
  })
];
const appPreset = defineUnimportPreset({
  from: "#app",
  imports: [
    "useLazyAsyncData",
    "refreshNuxtData",
    "defineNuxtComponent",
    "useNuxtApp",
    "defineNuxtPlugin",
    "useRuntimeConfig",
    "useState",
    "useLazyFetch",
    "useCookie",
    "useRequestHeaders",
    "useRequestEvent",
    "useRouter",
    "useRoute",
    "defineNuxtRouteMiddleware",
    "navigateTo",
    "abortNavigation",
    "addRouteMiddleware",
    "useNuxt2Meta",
    "clearError",
    "createError",
    "isNuxtError",
    "throwError",
    "showError",
    "useError"
  ]
});
const vueKeys = [
  // Lifecycle
  "onActivated",
  "onBeforeMount",
  "onBeforeUnmount",
  "onBeforeUpdate",
  "onDeactivated",
  "onErrorCaptured",
  "onMounted",
  "onRenderTracked",
  "onRenderTriggered",
  "onServerPrefetch",
  "onUnmounted",
  "onUpdated",
  // Reactivity
  "computed",
  "customRef",
  "isProxy",
  "isReactive",
  "isReadonly",
  "isRef",
  "markRaw",
  "proxyRefs",
  "reactive",
  "readonly",
  "ref",
  "shallowReactive",
  "shallowReadonly",
  "shallowRef",
  "toRaw",
  "toRef",
  "toRefs",
  "triggerRef",
  "unref",
  "watch",
  "watchEffect",
  "isShallow",
  // effect
  "effectScope",
  "getCurrentScope",
  "onScopeDispose",
  // Component
  "defineComponent",
  // TODO: https://github.com/vuejs/vue/pull/12684
  "defineAsyncComponent",
  "getCurrentInstance",
  "h",
  "inject",
  "nextTick",
  "provide",
  "useAttrs",
  "useCssModule",
  "useCssVars",
  "useSlots"
];
const vuePreset = defineUnimportPreset({
  from: "vue",
  imports: vueKeys
});
const vueRouterPreset = defineUnimportPreset({
  from: "vue-router/composables",
  imports: [
    "onBeforeRouteLeave",
    "onBeforeRouteUpdate",
    "useLink"
  ]
});
const defaultPresets = [
  ...commonPresets,
  appPreset,
  vueRouterPreset,
  vuePreset
];

async function scanForComposables(dir, ctx) {
  const performScan = async (entry) => {
    const files = await resolveFiles(entry, [
      "*.{ts,js,mjs,cjs,mts,cts}",
      "*/index.{ts,js,mjs,cjs,mts,cts}"
    ]);
    await ctx.modifyDynamicImports(async (dynamicImports) => {
      await Promise.all(
        files.map(async (path) => {
          filterInPlace(dynamicImports, (i) => i.from !== path);
          const code = await promises.readFile(path, "utf-8");
          const exports = findExports(code);
          const defaultExport = exports.find((i) => i.type === "default");
          if (defaultExport) {
            let name = parse$1(path).name;
            if (name === "index") {
              name = parse$1(path.split("/").slice(0, -1).join("/")).name;
            }
            dynamicImports.push({ name: "default", as: camelCase(name), from: path });
          }
          for (const exp of exports) {
            if (exp.type === "named") {
              for (const name of exp.names) {
                dynamicImports.push({ name, as: name, from: path });
              }
            } else if (exp.type === "declaration") {
              dynamicImports.push({ name: exp.name, as: exp.name, from: path });
            }
          }
        })
      );
    });
  };
  for (const entry of Array.isArray(dir) ? dir : [dir]) {
    if (!existsSync(entry)) {
      continue;
    }
    await performScan(entry);
  }
}
function filterInPlace(arr, predicate) {
  let i = arr.length;
  while (i--) {
    if (!predicate(arr[i])) {
      arr.splice(i, 1);
    }
  }
}

const importsModule = defineNuxtModule({
  meta: {
    name: "imports",
    configKey: "imports"
  },
  defaults: {
    autoImport: true,
    presets: defaultPresets,
    global: false,
    imports: [],
    dirs: [],
    transform: {
      include: [],
      exclude: void 0
    }
  },
  async setup(options, nuxt) {
    await nuxt.callHook("imports:sources", options.presets);
    options.presets?.forEach((_i) => {
      const i = _i;
      if (typeof i !== "string" && i.names && !i.imports) {
        i.imports = i.names;
        logger.warn("imports: presets.names is deprecated, use presets.imports instead");
      }
    });
    const ctx = createUnimport({
      presets: options.presets,
      imports: options.imports
    });
    let composablesDirs = [];
    for (const layer of nuxt.options._layers) {
      composablesDirs.push(resolve(layer.config.srcDir, "composables"));
      for (const dir of layer.config.imports?.dirs ?? layer.config.autoImports?.dirs ?? []) {
        composablesDirs.push(resolve(layer.config.srcDir, dir));
      }
    }
    await nuxt.callHook("imports:dirs", composablesDirs);
    composablesDirs = composablesDirs.map((dir) => normalize(dir));
    addTemplate({
      filename: "imports.mjs",
      getContents: () => ctx.toExports()
    });
    nuxt.options.alias["#imports"] = join$1(nuxt.options.buildDir, "imports");
    if (nuxt.options.dev && options.global) {
      addPluginTemplate({
        filename: "imports.mjs",
        getContents: async () => {
          const imports = await ctx.getImports();
          const importStatement = toImports(imports);
          const globalThisSet = imports.map((i) => `globalThis.${i.as} = ${i.as};`).join("\n");
          return `${importStatement}

${globalThisSet}

export default () => {};`;
        }
      });
    } else {
      addVitePlugin(TransformPlugin.vite({ ctx, options }));
      addWebpackPlugin(TransformPlugin.webpack({ ctx, options }));
    }
    const regenerateImports = async () => {
      await scanForComposables(composablesDirs, ctx);
      await ctx.modifyDynamicImports(async (imports) => {
        await nuxt.callHook("imports:extend", imports);
      });
    };
    await regenerateImports();
    addDeclarationTemplates(ctx, options);
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "types/imports.d.ts") });
      references.push({ path: resolve(nuxt.options.buildDir, "imports.d.ts") });
    });
    nuxt.options.build.watch.push(...composablesDirs);
    nuxt.hook("builder:watch", async (_, path) => {
      const _resolved = resolve(nuxt.options.srcDir, path);
      if (composablesDirs.find((dir) => _resolved.startsWith(dir))) {
        await nuxt.callHook("builder:generateApp");
      }
    });
    nuxt.hook("builder:generateApp", async () => {
      await regenerateImports();
    });
  }
});
function addDeclarationTemplates(ctx, options) {
  const nuxt = useNuxt();
  const stripExtension = (path) => path.replace(/\.[a-z]+$/, "");
  const resolved = {};
  const r = ({ from }) => {
    if (resolved[from]) {
      return resolved[from];
    }
    let path = resolveAlias(from);
    if (isAbsolute(path)) {
      path = relative(join$1(nuxt.options.buildDir, "types"), path);
    }
    path = stripExtension(path);
    resolved[from] = path;
    return path;
  };
  addTemplate({
    filename: "imports.d.ts",
    getContents: () => ctx.toExports()
  });
  addTemplate({
    filename: "types/imports.d.ts",
    getContents: async () => "// Generated by auto imports\n" + (options.autoImport ? await ctx.generateTypeDeclarations({ resolvePath: r }) : "// Implicit auto importing is disabled, you can use explicitly import from `#imports` instead.")
  });
}

const extensions = ["ts", "tsx", "cts", "mts"];
const typescriptRE = /\.[cm]?tsx?$/;
function setupTypescript() {
  const nuxt = useNuxt();
  nuxt.options.extensions.push(...extensions);
  nuxt.options.build.additionalExtensions.push(...extensions);
  nuxt.options.build.babel.plugins = nuxt.options.build.babel.plugins || [];
  if (nuxt.options.buildModules.includes("@nuxt/typescript-build")) {
    throw new Error("Please remove `@nuxt/typescript-build` from `buildModules` or set `bridge.typescript: false` to avoid conflict with bridge.");
  }
  const _require = createRequire(import.meta.url);
  nuxt.options.build.babel.plugins.unshift(
    _require.resolve("@babel/plugin-proposal-optional-chaining"),
    _require.resolve("@babel/plugin-proposal-nullish-coalescing-operator"),
    _require.resolve("@babel/plugin-transform-typescript")
  );
  extendWebpackConfig((config) => {
    config.resolve.extensions.push(...extensions.map((e) => `.${e}`));
    const babelRule = config.module.rules.find((rule) => rule.test?.test("test.js"));
    config.module.rules.unshift({
      ...babelRule,
      test: typescriptRE
    });
  });
}

const components = ["NoScript", "Link", "Base", "Title", "Meta", "Style", "Head", "Html", "Body"];
const metaModule = defineNuxtModule({
  meta: {
    name: "meta"
  },
  defaults: {
    charset: "utf-8",
    viewport: "width=device-width, initial-scale=1"
  },
  setup(options, nuxt) {
    const runtimeDir = nuxt.options.alias["#head"] || resolve(distDir, "head/runtime");
    nuxt.options.alias["#head"] = runtimeDir;
    const componentsPath = resolve(runtimeDir, "components");
    for (const componentName of components) {
      addComponent({
        name: componentName,
        filePath: componentsPath,
        export: componentName,
        // built-in that we do not expect the user to override
        priority: 10,
        // kebab case version of these tags is not valid
        kebabName: componentName
      });
    }
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport
    });
    addTemplate({
      filename: "meta.config.mjs",
      getContents: () => "export default " + JSON.stringify({ globalMeta, mixinKey: "setup" })
    });
    addImportsSources({
      from: "@unhead/vue",
      // hard-coded for now we so don't support auto-imports on the deprecated composables
      imports: [
        "injectHead",
        "useHead",
        "useSeoMeta",
        "useHeadSafe",
        "useServerHead",
        "useServerSeoMeta",
        "useServerHeadSafe"
      ]
    });
    addPlugin({ src: resolve(runtimeDir, "plugin") });
    addPlugin({ src: resolve(runtimeDir, "plugins/unhead") });
  }
});

const checkDocsMsg = "Please see https://nuxt.com/docs for more information.";
const msgPrefix = "[bridge] [meta]";
const setupMeta = async (opts) => {
  const nuxt = useNuxt();
  if (opts.needsExplicitEnable) {
    const metaPath = addTemplate({
      filename: "meta.mjs",
      getContents: () => ["useHead", "useMeta"].map((fnName) => `export const ${fnName} = () => console.warn('${msgPrefix} To enable experimental \`useHead\` support, set \`bridge.meta\` to \`true\` in your \`nuxt.config\`. ${checkDocsMsg}')`).join("\n")
    });
    nuxt.options.alias["#head"] = metaPath.dst;
    return;
  }
  if (nuxt.options.head && typeof nuxt.options.head === "function") {
    throw new TypeError(`${msgPrefix} The head() function in \`nuxt.config\` has been deprecated and in Nuxt 3 will need to be moved to \`app.vue\`. ${checkDocsMsg}`);
  }
  const runtimeDir = resolve(distDir, "runtime/head");
  nuxt.options.alias["#head"] = runtimeDir;
  await installModule(metaModule);
};

const setupTranspile = () => {
  const nuxt = useNuxt();
  nuxt.hook("modules:done", () => {
    const modules = [
      "@nuxt/bridge-edge",
      ...nuxt.options.buildModules,
      ...nuxt.options.modules,
      ...nuxt.options._modules
    ].map((m) => typeof m === "string" ? m : Array.isArray(m) ? m[0] : m.src).filter((m) => typeof m === "string").map((m) => m.split(/node_modules[\\/]/g).pop());
    nuxt.options.build.transpile = nuxt.options.build.transpile.map((m) => typeof m === "string" ? m.split(/node_modules[\\/]/g).pop() : m);
    function isTranspilePresent(mod) {
      return nuxt.options.build.transpile.some((t) => !(t instanceof Function) && (t instanceof RegExp ? t.test(mod) : new RegExp(t).test(mod)));
    }
    for (const module of modules) {
      if (!isTranspilePresent(module)) {
        nuxt.options.build.transpile.push(module);
      }
    }
  });
};

function uniq(arr) {
  return Array.from(new Set(arr));
}
const IS_CSS_RE = /\.(?:css|scss|sass|postcss|less|stylus|styl)(\?[^.]+)?$/;
function isCSS(file) {
  return IS_CSS_RE.test(file);
}
function hashId(id) {
  return "$id_" + hash(id);
}
function hash(input, length = 8) {
  return createHash("sha256").update(input).digest("hex").slice(0, length);
}

const DEFAULT_APP_TEMPLATE = `
<!DOCTYPE html>
<html {{ HTML_ATTRS }}>
<head {{ HEAD_ATTRS }}>
  {{ HEAD }}
</head>
<body {{ BODY_ATTRS }}>
  {{ APP }}
</body>
</html>
`;
async function prepareManifests(ctx) {
  const rDist = (...args) => resolve(ctx.nuxt.options.buildDir, "dist", ...args);
  await fse.mkdirp(rDist("server"));
  const customAppTemplateFile = resolve(ctx.nuxt.options.srcDir, "app.html");
  const APP_TEMPLATE = fse.existsSync(customAppTemplateFile) ? await fse.readFile(customAppTemplateFile, "utf-8") : DEFAULT_APP_TEMPLATE;
  const DEV_TEMPLATE = APP_TEMPLATE.replace(
    "</body>",
    '<script type="module" src="/@vite/client"><\/script><script type="module" src="/.nuxt/client.js"><\/script></body>'
  );
  const SPA_TEMPLATE = ctx.nuxt.options.dev ? DEV_TEMPLATE : APP_TEMPLATE;
  const SSR_TEMPLATE = ctx.nuxt.options.dev ? DEV_TEMPLATE : APP_TEMPLATE;
  await fse.writeFile(rDist("server/index.ssr.html"), SSR_TEMPLATE);
  await fse.writeFile(rDist("server/index.spa.html"), SPA_TEMPLATE);
  if (ctx.nuxt.options.dev) {
    await generateDevSSRManifest(ctx);
  } else {
    await generateBuildManifest(ctx);
  }
}
async function generateBuildManifest(ctx) {
  const rDist = (...args) => resolve(ctx.nuxt.options.buildDir, "dist", ...args);
  const clientManifest = await fse.readJSON(rDist("client/manifest.json"));
  const buildAssetsDir = withTrailingSlash(withoutLeadingSlash(ctx.nuxt.options.app.buildAssetsDir));
  const BASE_RE = new RegExp(`^${escapeRE(buildAssetsDir)}`);
  for (const key in clientManifest) {
    if (clientManifest[key].file) {
      clientManifest[key].file = clientManifest[key].file.replace(BASE_RE, "");
    }
    for (const item of ["css", "assets"]) {
      if (clientManifest[key][item]) {
        clientManifest[key][item] = clientManifest[key][item].map((i) => i.replace(BASE_RE, ""));
      }
    }
  }
  const polyfillName = Object.values(clientManifest).find((entry) => entry.file.startsWith("polyfills-legacy"))?.file;
  const polyfill = await fse.readFile(rDist("client", buildAssetsDir, polyfillName), "utf-8");
  const clientImports = /* @__PURE__ */ new Set();
  const clientEntry = {
    assets: /* @__PURE__ */ new Set(),
    css: /* @__PURE__ */ new Set(),
    dynamicImports: /* @__PURE__ */ new Set()
  };
  for (const entry in clientManifest) {
    if (!clientManifest[entry].file.startsWith("polyfills-legacy") && clientManifest[entry].file.includes("-legacy")) {
      clientImports.add(clientManifest[entry].file);
      for (const key of ["css", "assets", "dynamicImports"]) {
        for (const file of clientManifest[entry][key] || []) {
          clientEntry[key].add(file);
        }
      }
    }
    delete clientManifest[entry].isEntry;
  }
  const clientEntryCode = [
    polyfill,
    "var appConfig = window && window.__NUXT__ && window.__NUXT__.config.app || {}",
    'var publicBase = appConfig.cdnURL || appConfig.baseURL || "/"',
    'function joinURL (a, b) { return a.replace(/\\/+$/, "") + "/" + b.replace(/^\\/+/, "") }',
    'globalThis.__publicAssetsURL = function(id) { return joinURL(publicBase, id || "") }',
    'globalThis.__buildAssetsURL = function(id) { return joinURL(publicBase, joinURL(appConfig.buildAssetsDir, id || "")) }',
    `var imports = ${JSON.stringify([...clientImports])};`,
    "imports.reduce(function(p, id){return p.then(function(){return System.import(__buildAssetsURL(id))})}, Promise.resolve())"
  ].join("\n");
  const clientEntryName = "entry-legacy." + hash(clientEntryCode) + ".js";
  await fse.writeFile(rDist("client", buildAssetsDir, clientEntryName), clientEntryCode, "utf-8");
  const manifest = normalizeViteManifest({
    [clientEntryName]: {
      file: clientEntryName,
      module: true,
      isEntry: true,
      css: [...clientEntry.css],
      assets: [...clientEntry.assets],
      dynamicImports: [...clientEntry.dynamicImports]
    },
    ...clientManifest
  });
  await writeClientManifest(manifest, ctx.nuxt.options.buildDir);
  await fse.remove(rDist("client/manifest.json"));
}
async function generateDevSSRManifest(ctx, css = []) {
  const devClientManifest = {
    "@vite/client": {
      isEntry: true,
      file: "@vite/client",
      css,
      module: true,
      resourceType: "script"
    },
    "entry.mjs": {
      isEntry: true,
      file: "entry.mjs",
      module: true,
      resourceType: "script"
    }
  };
  await writeClientManifest(normalizeViteManifest(devClientManifest), ctx.nuxt.options.buildDir);
}
async function writeClientManifest(clientManifest, buildDir) {
  const clientManifestJSON = JSON.stringify(clientManifest, null, 2);
  await fse.writeFile(resolve(buildDir, "dist/server/client.manifest.json"), clientManifestJSON, "utf-8");
  await fse.writeFile(resolve(buildDir, "dist/server/client.manifest.mjs"), `export default ${clientManifestJSON}`, "utf-8");
}

async function generateWebpackBuildManifest() {
  const nuxt = useNuxt();
  const rDist = (...args) => resolve(nuxt.options.buildDir, "dist", ...args);
  const webpackManifest = await fse.readJSON(rDist("server/client.manifest.json"));
  const manifest = normalizeWebpackManifest(webpackManifest);
  await writeClientManifest(manifest, nuxt.options.buildDir);
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-bridge",
    configKey: "bridge"
  },
  defaults: {
    nitro: true,
    nitroGenerator: true,
    vite: false,
    app: {},
    capi: {},
    transpile: true,
    imports: true,
    compatibility: true,
    meta: null,
    typescript: true,
    resolve: true
  },
  async setup(opts, nuxt) {
    if (nuxt.options.bridge === false) {
      return;
    }
    if (!nuxt.options.bridge._version) {
      throw new Error("[bridge] Bridge must be enabled by using `defineNuxtConfig` to wrap your Nuxt configuration.");
    }
    if (opts.vite && !opts.nitro && !nuxt.options.dev) {
      throw new Error("[bridge] Vite build will not work unless Nitro is enabled.");
    }
    if (opts.nitro) {
      nuxt.options.router.base = nuxt.options.app.baseURL || "/";
      nuxt.hook("modules:done", async () => {
        await setupNitroBridge();
      });
      if (!opts.vite) {
        nuxt.hook("build:compile", () => {
          nuxt.hook("server:devMiddleware", async (devMiddleware) => {
            await nuxt.callHook("server:devHandler", fromNodeMiddleware(devMiddleware));
          });
        });
      }
    }
    if (opts.app) {
      await setupAppBridge(opts.app);
    }
    if (opts.capi) {
      if (!opts.app) {
        throw new Error("[bridge] Cannot enable composition-api with app disabled!");
      }
      await setupCAPIBridge(opts.capi === true ? {} : opts.capi);
    }
    nuxt.hooks.deprecateHooks({
      // @ts-expect-error
      "autoImports:sources": {
        to: "imports:sources",
        message: "`autoImports:sources` hook is deprecated. Use `addImportsSources()` from `@nuxt/kit` or `imports:dirs` with latest Nuxt Bridge."
      },
      "autoImports:dirs": {
        to: "imports:dirs",
        message: "`autoImports:dirs` hook is deprecated. Use `addImportsDir()` from `@nuxt/kit` or `imports:dirs` with latest Nuxt Bridge."
      },
      "autoImports:extend": {
        to: "imports:extend",
        message: "`autoImports:extend` hook is deprecated. Use `addImports()` from `@nuxt/kit` or `imports:extend` with latest Nuxt Bridge."
      }
    });
    if (opts.imports === false || opts.autoImports === false) {
      logger.warn(
        "`bridge.imports` and `bridge.autoImports` are deprecated. Use `imports.autoImport` instead.",
        "Please see https://nuxt.com/docs/guide/concepts/auto-imports#disabling-auto-imports for more information."
      );
    }
    if (opts.imports ?? opts.autoImports) {
      nuxt.hook(
        "modules:done",
        (moduleContainer) => installModule(
          importsModule.bind(moduleContainer, {
            autoImport: nuxt.options.imports?.autoImport ?? opts.imports ?? opts.autoImports
          })
        )
      );
    }
    if (opts.vite) {
      const viteModule = await import('../chunks/module.mjs').then((r) => r.default || r);
      nuxt.hook("modules:done", (moduleContainer) => installModule(viteModule.bind(moduleContainer)));
    } else {
      nuxt.options.build.transpile.push("vue");
      nuxt.hook("build:done", async () => {
        if (opts.nitro && !nuxt.options.dev && !nuxt.options._prepare) {
          await generateWebpackBuildManifest();
        }
      });
    }
    if (opts.typescript) {
      await setupTypescript();
    }
    if (opts.resolve) {
      setupBetterResolve();
    }
    if (opts.transpile) {
      setupTranspile();
    }
    if (opts.compatibility) {
      nuxt.hook("modules:done", async (moduleContainer) => {
        for (const [name, m] of Object.entries(moduleContainer.requiredModules || {})) {
          const compat = m?.handler?.meta?.compatibility || {};
          if (compat) {
            const issues = await checkNuxtCompatibility(compat, nuxt);
            if (issues.length) {
              console.warn(`[bridge] Detected module incompatibility issues for \`${name}\`:
` + issues.toString());
            }
          }
        }
      });
    }
    if (opts.meta !== false && opts.capi) {
      await setupMeta({ needsExplicitEnable: opts.meta === null });
    }
  }
});

export { pkgDir as a, distDir as d, generateDevSSRManifest as g, hashId as h, isCSS as i, module as m, prepareManifests as p, uniq as u };
