import { existsSync, readdirSync } from 'node:fs';
import { defineUntypedSchema } from 'untyped';
import { resolve, join } from 'pathe';
import defu from 'defu';
import { isCI, isTest } from 'std-env';
import { withTrailingSlash, normalizeURL, joinURL } from 'ufo';
import createRequire from 'create-require';
import { pascalCase } from 'scule';
import jiti from 'jiti';

const app = defineUntypedSchema({
  vue: {
    /**
     * Properties that will be set directly on `Vue.config` for vue@2.
     * @see [vue@2 Documentation](https://v2.vuejs.org/v2/api/#Global-Config)
     * @type {typeof import('vue/types/vue').VueConfiguration}
     */
    config: {
      silent: {
        $resolve: async (val, get) => val ?? !await get("dev")
      },
      performance: {
        $resolve: async (val, get) => val ?? await get("dev")
      }
    }
  },
  app: {
    /**
     * The base path of your Nuxt application.
     *
     * This can be set at runtime by setting the NUXT_APP_BASE_URL environment variable.
     * @example
     * ```bash
     * NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
     * ```
     */
    baseURL: {
      $resolve: (val) => val || process.env.NUXT_APP_BASE_URL || "/"
    },
    /** The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set). This is set at build time and should not be customized at runtime. */
    buildAssetsDir: {
      $resolve: (val) => val || process.env.NUXT_APP_BUILD_ASSETS_DIR || "/_nuxt/"
    },
    /**
     * The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set).
     * @deprecated - use `buildAssetsDir` instead
     */
    assetsPath: {
      $resolve: async (val, get) => val ?? await get("buildAssetsDir")
    },
    /**
     * Set default configuration for `<head>` on every page.
     * @example
     * ```js
     * app: {
     *   head: {
     *     meta: [
     *       // <meta name="viewport" content="width=device-width, initial-scale=1">
     *       { name: 'viewport', content: 'width=device-width, initial-scale=1' }
     *     ],
     *     script: [
     *       // <script src="https://myawesome-lib.js"><\/script>
     *       { src: 'https://awesome-lib.js' }
     *     ],
     *     link: [
     *       // <link rel="stylesheet" href="https://myawesome-lib.css">
     *       { rel: 'stylesheet', href: 'https://awesome-lib.css' }
     *     ],
     *     // please note that this is an area that is likely to change
     *     style: [
     *       // <style type="text/css">:root { color: red }</style>
     *       { children: ':root { color: red }', type: 'text/css' }
     *     ],
     *     noscript: [
     *       // <noscript>JavaScript is required</noscript>
     *       { children: 'JavaScript is required' }
     *     ]
     *   }
     * }
     * ```
     * @type {typeof import('../src/types/head').AppHeadMetaObject}
     */
    head: {
      $resolve: async (val, get) => {
        const resolved = defu(val, await get("meta"), {
          meta: [],
          link: [],
          style: [],
          script: [],
          noscript: []
        });
        if (!resolved.meta.find((m) => m.charset)?.charset) {
          resolved.meta.unshift({ charset: resolved.charset || "utf-8" });
        }
        if (!resolved.meta.find((m) => m.name === "viewport")?.content) {
          resolved.meta.unshift({ name: "viewport", content: resolved.viewport || "width=device-width, initial-scale=1" });
        }
        resolved.meta = resolved.meta.filter(Boolean);
        resolved.link = resolved.link.filter(Boolean);
        resolved.style = resolved.style.filter(Boolean);
        resolved.script = resolved.script.filter(Boolean);
        resolved.noscript = resolved.noscript.filter(Boolean);
        return resolved;
      }
    }
  },
  /**
   * The path to an HTML template file for rendering Nuxt responses.
   * Uses `<srcDir>/app.html` if it exists, or the Nuxt's default template if not.
   * @example
   * ```html
   * <!DOCTYPE html>
   * <html {{ HTML_ATTRS }}>
   *   <head {{ HEAD_ATTRS }}>
   *     {{ HEAD }}
   *   </head>
   *   <body {{ BODY_ATTRS }}>
   *     {{ APP }}
   *   </body>
   * </html>
   * ```
   */
  appTemplatePath: {
    $resolve: async (val, get) => {
      if (val) {
        return resolve(await get("srcDir"), val);
      }
      if (existsSync(join(await get("srcDir"), "app.html"))) {
        return join(await get("srcDir"), "app.html");
      }
      return resolve(await get("buildDir"), "views/app.template.html");
    }
  },
  /**
   * Enable or disable Vuex store.
   *
   * By default, it is enabled if there is a `store/` directory.
   */
  store: {
    $resolve: async (val, get) => val !== false && existsSync(join(await get("srcDir"), await get("dir.store"))) && readdirSync(join(await get("srcDir"), await get("dir.store"))).find((filename) => filename !== "README.md" && filename[0] !== ".")
  },
  /**
   * Options to pass directly to `vue-meta`.
   * @see [documentation](https://vue-meta.nuxtjs.org/api/#plugin-options).
   * @type {typeof import('vue-meta').VueMetaOptions}
   */
  vueMeta: null,
  /**
   * Set default configuration for `<head>` on every page.
   * @see [documentation](https://vue-meta.nuxtjs.org/api/#metainfo-properties) for specifics.
   * @type {typeof import('vue-meta').MetaInfo}
   */
  head: {
    /** Each item in the array maps to a newly-created `<meta>` element, where object properties map to attributes. */
    meta: [],
    /** Each item in the array maps to a newly-created `<link>` element, where object properties map to attributes. */
    link: [],
    /** Each item in the array maps to a newly-created `<style>` element, where object properties map to attributes. */
    style: [],
    /** Each item in the array maps to a newly-created `<script>` element, where object properties map to attributes. */
    script: []
  },
  /**
   * @typeTODO {typeof import('../src/types/meta').AppHeadMetaObject}
   * @deprecated - use `head` instead
   */
  meta: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  /**
   * Configuration for the Nuxt `fetch()` hook.
   */
  fetch: {
    /** Whether to enable `fetch()` on the server. */
    server: true,
    /** Whether to enable `fetch()` on the client. */
    client: true
  },
  /**
   * You may want to extend plugins or change their order. For this, you can pass
   * a function using `extendPlugins`. It accepts an array of plugin objects and
   * should return an array of plugin objects.
   * @type {(plugins: Array<{ src: string, mode?: 'client' | 'server' }>) => Array<{ src: string, mode?: 'client' | 'server' }>}
   */
  extendPlugins: null,
  /**
   * An object where each key name maps to a path to a layout .vue file.
   *
   * Normally, there is no need to configure this directly.
   * @type {Record<string, string>}
   */
  layouts: {},
  /**
   * Set a custom error page layout.
   *
   * Normally, there is no need to configure this directly.
   * @type {string}
   */
  ErrorPage: null,
  /**
   * Configure the Nuxt loading progress bar component that's shown between
   * routes. Set to `false` to disable. You can also customize it or create
   * your own component.
   */
  loading: {
    /** CSS color of the progress bar. */
    color: "black",
    /**
     * CSS color of the progress bar when an error appended while rendering
     * the route (if data or fetch sent back an error, for example).
     */
    failedColor: "red",
    /** Height of the progress bar (used in the style property of the progress bar). */
    height: "2px",
    /**
     * In ms, wait for the specified time before displaying the progress bar.
     * Useful for preventing the bar from flashing.
     */
    throttle: 200,
    /**
     * In ms, the maximum duration of the progress bar, Nuxt assumes that the
     * route will be rendered before 5 seconds.
     */
    duration: 5e3,
    /** Keep animating progress bar when loading takes longer than duration. */
    continuous: false,
    /** Set the direction of the progress bar from right to left. */
    rtl: false,
    /** Set to `false` to remove default progress bar styles (and add your own). */
    css: true
  },
  /**
   * Show a loading spinner while the page is loading (only when `ssr: false`).
   *
   * Set to `false` to disable. Alternatively, you can pass a string name or an object for more
   * configuration. The name can refer to an indicator from [SpinKit](https://tobiasahlin.com/spinkit/)
   * or a path to an HTML template of the indicator source code (in this case, all the
   * other options will be passed to the template).
   */
  loadingIndicator: {
    $resolve: async (val, get) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "default",
        color: await get("loading.color") || "#D3D3D3",
        color2: "#F5F5F5",
        background: await get("manifest") && await get("manifest.theme_color") || "white",
        dev: await get("dev"),
        loading: await get("messages.loading")
      });
    }
  },
  /**
   * Used to set the default properties of the page transitions.
   *
   * You can either pass a string (the transition name) or an object with properties to bind
   * to the `<Transition>` component that will wrap your pages.
   * @see [vue@2 documentation](https://v2.vuejs.org/v2/guide/transitions.html)
   * @see [vue@3 documentation](https://vuejs.org/guide/built-ins/transition-group.html#enter-leave-transitions)
   */
  pageTransition: {
    $resolve: async (val, get) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "page",
        mode: "out-in",
        appear: await get("render.ssr") === false || Boolean(val),
        appearClass: "appear",
        appearActiveClass: "appear-active",
        appearToClass: "appear-to"
      });
    }
  },
  /**
   * Used to set the default properties of the layout transitions.
   *
   * You can either pass a string (the transition name) or an object with properties to bind
   * to the `<Transition>` component that will wrap your layouts.
   * @see [vue@2 documentation](https://v2.vuejs.org/v2/guide/transitions.html)
   */
  layoutTransition: {
    $resolve: (val) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "layout",
        mode: "out-in"
      });
    }
  },
  /**
   * You can disable specific Nuxt features that you do not want.
   */
  features: {
    /** Set to false to disable Nuxt vuex integration */
    store: true,
    /** Set to false to disable layouts */
    layouts: true,
    /** Set to false to disable Nuxt integration with `vue-meta` and the `head` property */
    meta: true,
    /** Set to false to disable middleware */
    middleware: true,
    /** Set to false to disable transitions */
    transitions: true,
    /** Set to false to disable support for deprecated features and aliases */
    deprecations: true,
    /** Set to false to disable the Nuxt `validate()` hook */
    validate: true,
    /** Set to false to disable the Nuxt `asyncData()` hook */
    useAsyncData: true,
    /** Set to false to disable the Nuxt `fetch()` hook */
    fetch: true,
    /** Set to false to disable `$nuxt.isOnline` */
    clientOnline: true,
    /** Set to false to disable prefetching behavior in `<NuxtLink>` */
    clientPrefetch: true,
    /** Set to false to disable extra component aliases like `<NLink>` and `<NChild>` */
    componentAliases: true,
    /** Set to false to disable the `<ClientOnly>` component (see [docs](https://github.com/egoist/vue-client-only)) */
    componentClientOnly: true
  }
});

const build = defineUntypedSchema({
  build: {
    /**
     * Suppresses most of the build output log.
     *
     * It is enabled by default when a CI or test environment is detected.
     *
     * @see [std-env](https://github.com/unjs/std-env)
     */
    quiet: Boolean(isCI || isTest),
    /**
     * Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.
     *
     * Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).
     *
     * @example
     * ```js
     * analyze: {
     *   analyzerMode: 'static'
     * }
     * ```
     * @type {boolean | typeof import('webpack-bundle-analyzer').BundleAnalyzerPlugin.Options | typeof import('rollup-plugin-visualizer').PluginVisualizerOptions}
     */
    analyze: {
      $resolve: async (val, get) => {
        if (val !== true) {
          return val ?? false;
        }
        const rootDir = await get("rootDir");
        return {
          template: "treemap",
          projectRoot: rootDir,
          filename: join(rootDir, ".nuxt/stats", "{name}.html")
        };
      }
    },
    /**
     * Enable the profiler in webpackbar.
     *
     * It is normally enabled by CLI argument `--profile`.
     *
     * @see [webpackbar](https://github.com/unjs/webpackbar#profile)
     */
    profile: process.argv.includes("--profile"),
    /**
     * Enables Common CSS Extraction using
     * [Vue Server Renderer guidelines](https://v2.ssr.vuejs.org/guide/css.html).
     *
     * Using [extract-css-chunks-webpack-plugin](https://github.com/faceyspacey/extract-css-chunks-webpack-plugin/) under the hood, your CSS will be extracted
     * into separate files, usually one per component. This allows caching your CSS and
     * JavaScript separately and is worth trying if you have a lot of global or shared CSS.
     *
     * @example
     * ```js
     * export default {
     *   build: {
     *     extractCSS: true,
     *     // or
     *     extractCSS: {
     *       ignoreOrder: true
     *     }
     *   }
     * }
     * ```
     *
     * If you want to extract all your CSS to a single file, there is a workaround for this.
     * However, note that it is not recommended to extract everything into a single file.
     * Extracting into multiple CSS files is better for caching and preload isolation. It
     * can also improve page performance by downloading and resolving only those resources
     * that are needed.
     * @example
     * ```js
     * export default {
     *   build: {
     *     extractCSS: true,
     *     optimization: {
     *       splitChunks: {
     *         cacheGroups: {
     *           styles: {
     *             name: 'styles',
     *             test: /\.(css|vue)$/,
     *             chunks: 'all',
     *             enforce: true
     *           }
     *         }
     *       }
     *     }
     *   }
     * }
     * ```
     * @type {boolean | typeof import('extract-css-chunks-webpack-plugin').PluginOptions}
     */
    extractCSS: false,
    /**
     * Enables CSS source map support (defaults to true in development)
     */
    cssSourceMap: {
      $resolve: async (val, get) => val ?? (await get("sourcemap.client") || await get("sourcemap.server")) ?? await get("dev")
    },
    /**
     * Creates special webpack bundle for SSR renderer. It is normally not necessary to change this value.
     */
    ssr: void 0,
    /**
     * Enable [thread-loader](https://github.com/webpack-contrib/thread-loader#thread-loader) when building app with webpack.
     *
     * @warning This is an unstable feature.
     */
    parallel: {
      $resolve: async (val, get) => await get("build.extractCSS") ? false : Boolean(val)
    },
    /**
     * Enable caching for [`terser-webpack-plugin`](https://github.com/webpack-contrib/terser-webpack-plugin#options)
     * and [`cache-loader`](https://github.com/webpack-contrib/cache-loader#cache-loader).
     *
     * @warning This is an unstable feature.
     */
    cache: false,
    /**
     * Inline server bundle dependencies.
     *
     * This mode bundles `node_modules` that are normally preserved as externals in the server build.
     *
     * @warning Runtime dependencies (modules, `nuxt.config`, server middleware and the static directory) are not bundled.
     * This feature only disables use of [webpack-externals](https://webpack.js.org/configuration/externals/) for server-bundle.
     * @note You can enable standalone bundling by passing `--standalone` via the command line.
     * @see [context](https://github.com/nuxt/nuxt.js/pull/4661)
     */
    standalone: false,
    /**
     * If you are uploading your dist files to a CDN, you can set the publicPath to your CDN.
     *
     * @note This is only applied in production.
     *
     * The value of this property at runtime will override the configuration of an app that
     * has already been built.
     * @example
     * ```js
     * build: {
     *   publicPath: process.env.PUBLIC_PATH || 'https://cdn.nuxtjs.org'
     * }
     * ```
     */
    publicPath: {
      $resolve: async (val, get) => val ? withTrailingSlash(normalizeURL(val)) : await get("app").buildAssetsDir
    },
    /**
     * The polyfill library to load to provide URL and URLSearchParams.
     *
     * Defaults to `'url'` ([see package](https://www.npmjs.com/package/url)).
     */
    serverURLPolyfill: "url",
    /**
     * Customize bundle filenames.
     *
     * To understand a bit more about the use of manifests, take a look at [this webpack documentation](https://webpack.js.org/guides/code-splitting/).
     *
     * @note Be careful when using non-hashed based filenames in production
     * as most browsers will cache the asset and not detect the changes on first load.
     *
     * This example changes fancy chunk names to numerical ids:
     * @example
     * ```js
     * filenames: {
     *   chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js')
     * }
     * ```
     * @type {Record<string, ((arg: any) => string)>}
     */
    filenames: {
      app: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
      chunk: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
      css: ({ isDev }) => isDev ? "[name].css" : "css/[contenthash:7].css",
      img: ({ isDev }) => isDev ? "[path][name].[ext]" : "img/[name].[contenthash:7].[ext]",
      font: ({ isDev }) => isDev ? "[path][name].[ext]" : "fonts/[name].[contenthash:7].[ext]",
      video: ({ isDev }) => isDev ? "[path][name].[ext]" : "videos/[name].[contenthash:7].[ext]"
    },
    /**
     * Customize the options of Nuxt's integrated webpack loaders.
     */
    loaders: {
      $resolve: async (val, get) => {
        const styleLoaders = [
          "css",
          "cssModules",
          "less",
          "sass",
          "scss",
          "stylus",
          "vueStyle"
        ];
        for (const name of styleLoaders) {
          const loader = val[name];
          if (loader && loader.sourcemap === void 0) {
            loader.sourcemap = Boolean(await get("build.cssSourceMap"));
          }
        }
        return val;
      },
      file: { esModule: false },
      fontUrl: { esModule: false, limit: 1e3 },
      imgUrl: { esModule: false, limit: 1e3 },
      pugPlain: {},
      vue: {
        productionMode: { $resolve: async (val, get) => val ?? !await get("dev") },
        transformAssetUrls: {
          video: "src",
          source: "src",
          object: "src",
          embed: "src"
        },
        compilerOptions: { $resolve: async (val, get) => val ?? await get("vue.compilerOptions") }
      },
      css: {
        importLoaders: 0,
        esModule: false
      },
      cssModules: {
        importLoaders: 0,
        esModule: false,
        modules: {
          localIdentName: "[local]_[hash:base64:5]"
        }
      },
      less: {},
      sass: {
        sassOptions: {
          indentedSyntax: true
        }
      },
      scss: {},
      stylus: {},
      vueStyle: {}
    },
    /**
     * @deprecated  Use [style-resources-module](https://github.com/nuxt-community/style-resources-module/)
     */
    styleResources: {},
    /**
     * Add webpack plugins.
     *
     * @example
     * ```js
     * import webpack from 'webpack'
     * import { version } from './package.json'
     * // ...
     * plugins: [
     *   new webpack.DefinePlugin({
     *     'process.VERSION': version
     *   })
     * ]
     * ```
     */
    plugins: [],
    /**
     * Terser plugin options.
     *
     * Set to false to disable this plugin, or pass an object of options.
     *
     * @see [terser-webpack-plugin documentation](https://github.com/webpack-contrib/terser-webpack-plugin)
     * @note Enabling sourcemap will leave `//# sourcemappingURL` linking comment at
     * the end of each output file if webpack `config.devtool` is set to `source-map`.
     */
    terser: {},
    /**
     * Enables the [HardSourceWebpackPlugin](https://github.com/mzgoddard/hard-source-webpack-plugin) for improved caching.
     *
     * @warning unstable
     */
    hardSource: false,
    /**
     * Hard-replaces `typeof process`, `typeof window` and `typeof document` to tree-shake bundle.
     */
    aggressiveCodeRemoval: false,
    /**
     * OptimizeCSSAssets plugin options.
     *
     * Defaults to true when `extractCSS` is enabled.
     *
     * @see [optimize-css-assets-webpack-plugin documentation](https://github.com/NMFR/optimize-css-assets-webpack-plugin).
     */
    optimizeCSS: {
      $resolve: async (val, get) => val ?? (await get("build.extractCSS") ? {} : false)
    },
    /**
     * Configure [webpack optimization](https://webpack.js.org/configuration/optimization/).
     */
    optimization: {
      runtimeChunk: "single",
      /** Set minimize to false to disable all minimizers. (It is disabled in development by default) */
      minimize: {
        $resolve: async (val, get) => val ?? !await get("dev")
      },
      /** You can set minimizer to a customized array of plugins. */
      minimizer: void 0,
      splitChunks: {
        chunks: "all",
        automaticNameDelimiter: "/",
        cacheGroups: {}
      }
    },
    /**
     * Whether to split code for `layout`, `pages` and `commons` chunks.
     *
     * Commons libs include `vue`, `vue-loader`, `vue-router`, `vuex`, etc.
     */
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    /**
     * Nuxt will automatically detect the current version of `core-js` in your project (`'auto'`),
     * or you can specify which version you want to use (`2` or `3`).
     */
    corejs: "auto",
    /**
     * Customize your Babel configuration.
     *
     * See [babel-loader options](https://github.com/babel/babel-loader#options) and
     * [babel options](https://babeljs.io/docs/en/options).
     *
     * @note `.babelrc` is ignored by default.
     */
    babel: {
      configFile: false,
      babelrc: false,
      /**
       * An array of Babel plugins to load, or a function that takes webpack context and returns
       * an array of Babel plugins.
       *
       * For more information see [Babel plugins options](https://babeljs.io/docs/en/options#plugins)
       * and [babel-loader options](https://github.com/babel/babel-loader#options).
       */
      plugins: [],
      /**
       * The Babel presets to be applied.
       *
       * @note The presets configured here will be applied to both the client and the server
       * build. The target will be set by Nuxt accordingly (client/server). If you want to configure
       * the preset differently for the client or the server build, please use presets as a function.
       * @warning It is highly recommended to use the default preset instead customizing.
       * @example
       * ```js
       * export default {
       *   build: {
       *     babel: {
       *       presets({ isServer }, [ preset, options ]) {
       *         // change options directly
       *         options.targets = isServer ? '...' :  '...'
       *         options.corejs = '...'
       *         // return nothing
       *       }
       *     }
       *   }
       * }
       * ```
       * @example
       * ```js
       * export default {
       *   build: {
       *     babel: {
       *       presets({ isServer }, [preset, options]) {
       *         return [
       *           [
       *             preset,
       *             {
       *               targets: isServer ? '...' :  '...',
       *               ...options
       *             }
       *           ],
       *           [
       *             // Other presets
       *           ]
       *         ]
       *       }
       *     }
       *   }
       * }
       * ```
       */
      presets: {},
      cacheDirectory: {
        $resolve: async (val, get) => val ?? await get("dev")
      }
    },
    /**
     * Customize PostCSS Loader plugins.
     * Sames options as https://github.com/webpack-contrib/postcss-loader#options
     */
    postcss: {
      execute: void 0,
      postcssOptions: {
        $resolve: async (val, get) => {
          const postcssOptions = await get("postcss") || {};
          Object.assign(postcssOptions, defu(postcssOptions, val));
          return postcssOptions;
        }
      },
      sourcemap: void 0,
      implementation: void 0,
      order: ""
    },
    html: {
      /**
       * Configuration for the html-minifier plugin used to minify HTML files created
       * during the build process (will be applied for all modes).
       *
       * @warning If you make changes, they won't be merged with the defaults!
       * @example
       * ```js
       * export default {
       *   html: {
       *     minify: {
       *       collapseBooleanAttributes: true,
       *       decodeEntities: true,
       *       minifyCSS: true,
       *       minifyJS: true,
       *       processConditionalComments: true,
       *       removeEmptyAttributes: true,
       *       removeRedundantAttributes: true,
       *       trimCustomFragments: true,
       *       useShortDoctype: true
       *     }
       *   }
       * }
       * ```
       */
      minify: {
        collapseBooleanAttributes: true,
        decodeEntities: true,
        minifyCSS: true,
        minifyJS: true,
        processConditionalComments: true,
        removeEmptyAttributes: true,
        removeRedundantAttributes: true,
        trimCustomFragments: true,
        useShortDoctype: true
      }
    },
    /**
     * Allows setting a different app template (other than `@nuxt/vue-app`)
     */
    template: void 0,
    /**
     * You can provide your custom files to watch and regenerate after changes.
     *
     * This feature is especially useful for using with modules.
     *
     * @example
     * ```js
      watch: ['~/.nuxt/support.js']
     * ```
     */
    watch: [],
    /**
     * See [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware) for available options.
     */
    devMiddleware: {
      stats: "none"
    },
    /**
     * See [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware) for available options.
     */
    hotMiddleware: {},
    vendor: {
      $meta: {
        deprecated: "vendor has been deprecated since nuxt 2"
      }
    },
    /**
     * Set to `'none'` or `false` to disable stats printing out after a build.
     */
    stats: {
      $resolve: async (val, get) => val === "none" || await get("build.quiet") ? false : val,
      excludeAssets: [
        /.map$/,
        /index\..+\.html$/,
        /vue-ssr-(client|modern)-manifest.json/
      ]
    },
    /**
     * Set to `false` to disable the overlay provided by [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin).
     */
    friendlyErrors: true,
    /**
     * Additional extensions (beyond `['vue', 'js']` to support in `pages/`, `layouts/`, `middleware/`, etc.)
     */
    additionalExtensions: [],
    /**
     * Filters to hide build warnings.
     */
    warningIgnoreFilters: [],
    /**
     * Set to true to scan files within symlinks in the build (such as within `pages/`).
     */
    followSymlinks: false
  }
});

const cli = defineUntypedSchema({
  cli: {
    /**
     * Add a message to the CLI banner by adding a string to this array.
     *
     * @type {string[]}
     */
    badgeMessages: [],
    /**
     * Change the color of the 'Nuxt.js' title in the CLI banner.
     */
    bannerColor: "green"
  }
});

const common = defineUntypedSchema({
  /**
   * Your preferred code editor to launch when debugging.
   *
   * @see [documentation](https://github.com/yyx990803/launch-editor#supported-editors)
   * @type {string}
   */
  editor: void 0,
  /**
   * The watch property lets you watch custom files for restarting the server.
   *
   * `chokidar` is used to set up the watchers. To learn more about its pattern
   * options, see chokidar documentation.
   *
   * @see [chokidar](https://github.com/paulmillr/chokidar#api)
   * @example
   * ```js
   * watch: ['~/custom/*.js']
   * ```
   * @type {string[]}
   */
  watch: {
    $resolve: async (val, get) => {
      const rootDir = await get("rootDir");
      return Array.from(new Set(
        [].concat(val, await get("_nuxtConfigFiles")).filter(Boolean).map((p) => resolve(rootDir, p))
      ));
    }
  },
  /**
   * The style extensions that should be resolved by the Nuxt resolver (for example, in `css` property).
   */
  styleExtensions: [".css", ".pcss", ".postcss", ".styl", ".stylus", ".scss", ".sass", ".less"],
  dir: {
    /**
     * The assets directory (aliased as `~assets` in your build).
     */
    assets: "assets",
    /**
     * The directory containing app template files like `app.html` and `router.scrollBehavior.js`
     */
    app: "app",
    /**
     * Allows customizing the global ID used in the main HTML template as well as the main
     * Vue instance name and other options.
     */
    globalName: {
      $resolve: (val) => typeof val === "string" && /^[a-zA-Z]+$/.test(val) ? val.toLocaleLowerCase() : "nuxt"
    },
    /**
     * Whether to produce a separate modern build targeting browsers that support ES modules.
     *
     * Set to `'server'` to enable server mode, where the Nuxt server checks
     * browser version based on the user agent and serves the correct bundle.
     *
     * Set to `'client'` to serve both the modern bundle with `<script type="module">`
     * and the legacy bundle with `<script nomodule>`. It will also provide a
     * `<link rel="modulepreload">` for the modern bundle. Every browser that understands
     * the module type will load the modern bundle while older browsers fall back to the
     * legacy (transpiled) bundle.
     *
     * If you have set `modern: true` and are generating your app or have `ssr: false`,
     * modern will be set to `'client'`.
     *
     * If you have set `modern: true` and are serving your app, modern will be set to `'server'`.
     *
     * @see [concept of modern mode](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/)
     * @type {'server' | 'client' | boolean}
     */
    modern: void 0,
    /**
     * @deprecated use `ssr` option
     */
    mode: {
      $resolve: async (val, get) => val || (await get("ssr") ? "spa" : "universal"),
      $schema: { deprecated: "`mode` option is deprecated" }
    },
    /**
     * The `env` property defines environment variables that should be available
     * throughout your app (server- and client-side). They can be assigned using
     * server-side environment variables.
     *
     * @note Nuxt uses webpack's `definePlugin` to define these environment variables.
     * This means that the actual `process` or `process.env` from Node.js is neither
     * available nor defined. Each of the `env` properties defined here is individually
     * mapped to `process.env.xxxx` and converted during compilation.
     * @note Environment variables starting with `NUXT_ENV_` are automatically injected
     * into the process environment.
     */
    env: {
      $default: {},
      $resolve: (val) => {
        val = { ...val };
        for (const key in process.env) {
          if (key.startsWith("NUXT_ENV_")) {
            val[key] = process.env[key];
          }
        }
        return val;
      }
    },
    /**
     * Set the method Nuxt uses to require modules, such as loading `nuxt.config`, server
     * middleware, and so on - defaulting to `jiti` (which has support for TypeScript and ESM syntax).
     *
     * @see [jiti](https://github.com/unjs/jiti)
     * @type {'jiti' | 'native' | ((p: string | { filename: string }) => NodeRequire)}
     */
    createRequire: {
      $resolve: (val) => {
        val = process.env.NUXT_CREATE_REQUIRE || val || (typeof globalThis.jest !== "undefined" ? "native" : "jiti");
        if (val === "jiti") {
          return (p) => jiti(typeof p === "string" ? p : p.filename, { esmResolve: true });
        }
        if (val === "native") {
          return (p) => createRequire(typeof p === "string" ? p : p.filename);
        }
        return val;
      }
    },
    /**
     * Whether your Nuxt app should be built to be served by the Nuxt server (`server`)
     * or as static HTML files suitable for a CDN or other static file server (`static`).
     *
     * This is unrelated to `ssr`.
     *
     * @type {'server' | 'static'}
     */
    target: {
      $resolve: (val) => ["server", "static"].includes(val) ? val : "server"
    },
    /**
     * Customizes specific global names (they are based on `globalName` by default).
     */
    globals: {
      /** @type {(globalName: string) => string} */
      id: (globalName) => `__${globalName}`,
      /** @type {(globalName: string) => string} */
      nuxt: (globalName) => `$${globalName}`,
      /** @type {(globalName: string) => string} */
      context: (globalName) => `__${globalName.toUpperCase()}__`,
      /** @type {(globalName: string) => string} */
      pluginPrefix: (globalName) => globalName,
      /** @type {(globalName: string) => string} */
      readyCallback: (globalName) => `on${pascalCase(globalName)}Ready`,
      /** @type {(globalName: string) => string} */
      loadedCallback: (globalName) => `_on${pascalCase(globalName)}Loaded`
    },
    /**
     * The folder which will be used to auto-generate your Vuex store structure.
     */
    store: "store"
  },
  /**
   * Server middleware are connect/express/h3-shaped functions that handle server-side requests. They
   * run on the server and before the Vue renderer.
   *
   * By adding entries to `serverMiddleware` you can register additional routes without the need
   * for an external server.
   *
   * You can pass a string, which can be the name of a node dependency or a path to a file. You
   * can also pass an object with `path` and `handler` keys (`handler` can be a path or a
   * function).
   *
   * @note If you pass a function directly, it will only run in development mode.
   * @example
   * ```js
   * serverMiddleware: [
   *   // Will register redirect-ssl npm package
   *   'redirect-ssl',
   *   // Will register file from project server-middleware directory to handle /server-middleware/* requires
   *   { path: '/server-middleware', handler: '~/server-middleware/index.js' },
   *   // We can create custom instances too, but only in development mode, they are ignored for the production bundle.
   *   { path: '/static2', handler: serveStatic(fileURLToPath(new URL('./static2', import.meta.url))) }
   * ]
   * ```
   * @note If you don't want middleware to run on all routes you should use the object
   * form with a specific path.
   *
   * If you pass a string handler, Nuxt will expect that file to export a default function
   * that handles `(req, res, next) => void`.
   * @example
   * ```js
   * export default function (req, res, next) {
   *   // req is the Node.js http request object
   *   console.log(req.url)
   *   // res is the Node.js http response object
   *   // next is a function to call to invoke the next middleware
   *   // Don't forget to call next at the end if your middleware is not an endpoint!
   *   next()
   * }
   * ```
   *
   * Alternatively, it can export a connect/express/h3-type app instance.
   * @example
   * ```js
   * import bodyParser from 'body-parser'
   * import createApp from 'express'
   * const app = createApp()
   * app.use(bodyParser.json())
   * app.all('/getJSON', (req, res) => {
   *   res.json({ data: 'data' })
   * })
   * export default app
   * ```
   *
   * Alternatively, instead of passing an array of `serverMiddleware`, you can pass an object
   * whose keys are the paths and whose values are the handlers (string or function).
   * @example
   * ```js
   * export default {
   *   serverMiddleware: {
   *     '/a': '~/server-middleware/a.js',
   *     '/b': '~/server-middleware/b.js',
   *     '/c': '~/server-middleware/c.js'
   *   }
   * }
   * ```
   */
  serverMiddleware: {
    $resolve: (val) => {
      if (!val) {
        return [];
      }
      if (!Array.isArray(val)) {
        return Object.entries(val).map(([path, handler]) => ({ path, handler }));
      }
      return val;
    }
  }
});

const generate = defineUntypedSchema({
  generate: {
    /**
     * Directory name that holds all the assets and generated pages for a `static` build.
     */
    dir: {
      $resolve: async (val = "dist", get) => resolve(await get("rootDir"), val)
    },
    /** The number of routes that are generated concurrently in the same thread. */
    concurrency: 500,
    /**
     * Interval in milliseconds between two render cycles to avoid flooding a potential
     * API with calls.
     */
    interval: 0,
    /**
     * Set to `false` to disable creating a directory + `index.html` for each route.
     *
     * @example
     * ```bash
     * # subFolders: true
     * -| dist/
     * ---| index.html
     * ---| about/
     * -----| index.html
     * ---| products/
     * -----| item/
     * -------| index.html
     *
     * # subFolders: false
     * -| dist/
     * ---| index.html
     * ---| about.html
     * ---| products/
     * -----| item.html
     * ```
     */
    subFolders: true,
    /**
     * The path to the fallback HTML file.
     *
     * Set this as the error page in your static server configuration, so that unknown
     * routes can be rendered (on the client-side) by Nuxt.
     *
     * If unset or set to a falsy value, the name of the fallback HTML file will be `200.html`.
     * If set to `true`, the filename will be `404.html`.
     * If you provide a string as a value, it will be used instead.
     *
     * @note Multiple services (e.g. Netlify) detect a `404.html` automatically. If
     * you configure your web server on your own, please consult its documentation
     * to find out how to set up an error page (and set it to the `404.html` file).
     */
    fallback: { $resolve: (val) => val === true ? "400.html" : val || "200.html" },
    /**
     * Set to `false` to disable generating pages discovered through crawling relative
     * links in generated pages.
     */
    crawler: true,
    /** Set to `false` to disable generating a `manifest.js` with a list of all generated pages. */
    manifest: true,
    /** Set to `false` to disable generating a `.nojekyll` file (which aids compatibility with GitHub Pages). */
    nojekyll: true,
    /**
     * Configure the cache (used with `static` target to avoid rebuilding when no files have changed).
     *
     * Set to `false` to disable completely.
     *
     */
    cache: {
      /** An array of files or directories to ignore. (It can also be a function that returns an array.) */
      ignore: [],
      /**
       * Options to pass to [`globby`](https://github.com/sindresorhus/globby), which
       * is used to generate a 'snapshot' of the source files.
       */
      globbyOptions: {
        gitignore: true
      }
    },
    staticAssets: {
      /** The directory underneath `/_nuxt/`, where static assets (payload, state and manifest files) will live. */
      dir: "static",
      /**
       * The full path to the directory underneath `/_nuxt/` where static assets
       * (payload, state and manifest files) will live.
       */
      base: {
        $resolve: async (val, get) => val || joinURL((await get("app")).buildAssetsDir, await get("generate.dir"))
      },
      /** The full path to the versioned directory where static assets for the current build are located. */
      versionBase: {
        $resolve: async (val, get) => val || joinURL(await get("generate.base"), await get("generate.version"))
      },
      /** A unique string to uniquely identify payload versions (defaults to the current timestamp).  */
      version: {
        $resolve: (val) => val || String(Math.round(Date.now() / 1e3))
      }
    }
  }
});

const messages = defineUntypedSchema({
  messages: {
    /** The text that displays on the Nuxt loading indicator when `ssr: false`. */
    loading: "Loading...",
    /** The 404 text on the default Nuxt error page. */
    error_404: "This page could not be found",
    /** The text to display on the default Nuxt error page when there has been a server error. */
    server_error: "Server error",
    /** The text (linked to nuxtjs.org) that appears on the built-in Nuxt error page. */
    nuxtjs: "Nuxt",
    /** The text (linked to the home page) that appears on the built-in Nuxt error page. */
    back_to_home: "Back to the home page",
    /** The message that will display on a white screen if the built-in Nuxt error page can't be rendered. */
    server_error_details: "An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.",
    /** The default error title (if there isn't a specific error message) on the built-in Nuxt error page. */
    client_error: "Error",
    /** The error message (in debug mode) on the built-in Nuxt error page. */
    client_error_details: "An error occurred while rendering the page. Check developer tools console for details."
  }
});

const render = defineUntypedSchema({
  render: {
    /**
     * Use this option to customize the Vue SSR bundle renderer.
     * This option is skipped if `ssr: false`.
     *
     * Read [docs for Vue 2](https://ssr.vuejs.org/api/#renderer-options) here.
     */
    bundleRenderer: {
      shouldPrefetch: () => false,
      shouldPreload: (_fileWithoutQuery, asType) => ["script", "style"].includes(asType),
      /** enabled by default for development */
      runInNewContext: {
        $resolve: async (val, get) => val ?? await get("dev")
      }
    },
    /**
     * Configure the crossorigin attribute on `<link rel="stylesheet">` and `<script>`
     * tags in generated HTML. [More information](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin).
     */
    crossorigin: void 0,
    /**
     * Adds prefetch and preload links for faster initial page load time.
     * You probably don't want to disable this option unless you have many pages and routes.
     */
    resourceHints: true,
    /**
     * Whether to enable rendering of HTML - either dynamically (in server mode) or at generate time.
     *
     * This option is automatically set based on global SSR value if not provided.
     * This can be useful to dynamically enable/disable SSR at runtime after image builds
     * (with docker, for example).
     */
    ssr: void 0,
    /**
     * Forward server-side logs to the browser for better debugging (only available in development).
     *
     * Set to `collapsed` to collapse the logs, or `false` to disable.
     */
    ssrLog: {
      $resolve: async (val, get) => await get("dev") ? Boolean(val) : false
    },
    /**
     * Configuration for HTTP2 push headers.
     */
    http2: {
      /** Set to true to enable HTTP2 push headers. */
      push: false,
      /** @deprecated */
      shouldPush: null,
      /**
       * You can control what links to push using this function. It receives `req`,
       * `res`, `publicPath` and a `preloadFiles` array.
       *
       * You can add your own assets to the array as well. Using `req` and `res`
       * you can decide what links to push based on the request headers, for example
       * using the cookie with application version.
       *
       * Assets will be joined together with `,` and passed as a single `Link` header.
       *
       * @example
       * ```js
       * pushAssets: (req, res, publicPath, preloadFiles) =>
       *   preloadFiles
       *     .filter(f => f.asType === 'script' && f.file === 'runtime.js')
       *     .map(f => `<${publicPath}${f.file}>; rel=preload; as=${f.asType}`)
       * ```
       */
      pushAssets: null
    },
    /**
     * Configure the behavior of the `static/` directory.
     *
     * See [serve-static docs](https://github.com/expressjs/serve-static) for possible options.
     */
    static: {
      /**
       * Whether to add the router base to your static assets.
       *
       * @note some URL rewrites might not respect the prefix.
       * @example
       * Assets: favicon.ico
       * Router base: /t
       * With `prefix: true` (default): /t/favicon.ico
       * With `prefix: false`: /favicon.ico
       */
      prefix: true
    },
    /**
     * Configure server compression.
     *
     * Set to `false` to disable compression. You can also pass an object of options
     * for [compression middleware](https://www.npmjs.com/package/compression), or
     * use your own middleware by passing it in directly - for example,
     * `otherComp({ myOptions: 'example' })`.
     *
     * @type {boolean | object | Function}
     */
    compressor: {
      threshold: 0
    },
    /**
     * To disable etag for pages set `etag: false`. See
     * [etag docs](https://github.com/jshttp/etag) for possible options.
     * You can use your own hash function by specifying etag.hash:
     *
     * @example
     * ```js
     * import { murmurHash128 } from 'murmurhash-native'
     *
     * export default {
     *   render: {
     *     etag: {
     *       hash: html => murmurHash128(html)
     *     }
     *   }
     * }
     * ```
     * In this example we are using `murmurhash-native`, which is faster
     * for larger HTML body sizes. Note that the weak option is ignored
     * when specifying your own hash function.
     */
    etag: {
      hash: false,
      weak: false
    },
    /**
     * Use this to configure Content-Security-Policy to load external resources. [Read more](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).
     *
     * Set to `true` to enable, or you can pass options to fine-tune your CSP options.
     *
     * **Prerequisites**:
     * These CSP settings are only effective when using Nuxt with `mode: 'server'`
     * to serve your SSR application.
     *
     * **Updating settings**:
     * These settings are read by the Nuxt server directly from `nuxt.config`.
     * This means changes to these settings take effect when the server is restarted.
     * There is no need to rebuild the application to update CSP settings.
     *
     * @example
     * ```js
     * export default {
     *   render: {
     *     csp: {
     *       hashAlgorithm: 'sha256',
     *       policies: {
     *         'script-src': [
     *           'https://www.google-analytics.com',
     *           'https://name.example.com'
     *         ],
     *         'report-uri': ['https://report.example.com/report-csp-violations']
     *       },
     *       addMeta: true
     *     }
     *   }
     * }
     * ```
     *
     * The following example allows Google Analytics, LogRocket.io, and Sentry.io
     * for logging and analytic tracking.
     *
     * Review [this blog on Sentry.io](https://blog.sentry.io/2018/09/04/how-sentry-captures-csp-violations)
     * to learn what tracking link you should use.
     * @example
     * ```js
     * // PRIMARY_HOSTS = `loc.example-website.com`
     * export default {
     *   render: {
     *     csp: {
     *       reportOnly: true,
     *       hashAlgorithm: 'sha256',
     *       policies: {
     *         'default-src': ["'self'"],
     *         'img-src': ['https:', '*.google-analytics.com'],
     *         'worker-src': ["'self'", `blob:`, PRIMARY_HOSTS, '*.logrocket.io'],
     *         'style-src': ["'self'", "'unsafe-inline'", PRIMARY_HOSTS],
     *         'script-src': [
     *           "'self'",
     *           "'unsafe-inline'",
     *           PRIMARY_HOSTS,
     *           'sentry.io',
     *           '*.sentry-cdn.com',
     *           '*.google-analytics.com',
     *           '*.logrocket.io'
     *         ],
     *         'connect-src': [PRIMARY_HOSTS, 'sentry.io', '*.google-analytics.com'],
     *         'form-action': ["'self'"],
     *         'frame-ancestors': ["'none'"],
     *         'object-src': ["'none'"],
     *         'base-uri': [PRIMARY_HOSTS],
     *         'report-uri': [
     *           `https://sentry.io/api/<project>/security/?sentry_key=<key>`
     *         ]
     *       }
     *     }
     *   }
     * }
     * ```
     */
    csp: {
      $resolve: async (val, get) => {
        if (!val) {
          return false;
        }
        return {
          hashAlgorithm: "sha256",
          allowedSources: void 0,
          /** Policies to be added to the response `Content-Security-Policy` HTTP header. */
          policies: void 0,
          /**
           * Whether to add `<meta http-equiv="Content-Security-Policy"/>` to the `<head>`.
           * This is independent of the `csp.policies` configuration and the complete set
           * of the defined policies will still be added to the HTTP response header.
           *
           * @note CSP hashes will not be added as `<meta>` if `script-src` policy
           * contains 'unsafe-inline'. This is due to browsers ignoring 'unsafe-inline'
           * if hashes are present. (Set option `unsafeInlineCompatibility` to true to
           * disable this behavior.)
           */
          addMeta: Boolean(await get("target") === "static"),
          /**
           * Set option `unsafeInlineCompatibility` to `true` if you want both hashes and
           * 'unsafe-inline' for CSPv1 compatibility. In that case the `<meta>` tag will
           * still only contain the hashes of the inline `<script>` tags, and the policies
           * defined under `csp.policies` will be used in the `Content-Security-Policy`
           * HTTP response header.
           */
          unsafeInlineCompatibility: false,
          reportOnly: await get("debug"),
          ...val
        };
      }
    },
    /**
     * Options used for serving distribution files. Only applicable in production.
     *
     * See [serve-static docs](https://www.npmjs.com/package/serve-static) for possible options.
     */
    dist: {
      index: false,
      maxAge: "1y"
    },
    /**
     * Configure fallback behavior for [`serve-placeholder` middleware](https://github.com/nuxt/serve-placeholder).
     *
     * Example of allowing `.js` extension for routing (for example, `/repos/nuxt.js`):
     *
     * @example
     * ```js
     * export default {
     *   render: {
     *     fallback: {
     *       static: {
     *         // Avoid sending 404 for these extensions
     *         handlers: {
     *           '.js': false
     *         }
     *       }
     *     }
     *   }
     * }
     * ```
     */
    fallback: {
      /**
       * For routes matching the publicPath (`/_nuxt/*`).
       * Disable by setting to `false`.
       */
      dist: {},
      /**
       * For all other routes (`/*`).
       * Disable by setting to `false`.
       */
      static: {
        skipUnknown: true,
        handlers: {
          ".htm": false,
          ".html": false
        }
      }
    }
  }
});

const router = defineUntypedSchema({
  router: {
    /**
     * Configure the router mode.
     *
     * For server-side rendering it is not recommended to change it.
     */
    mode: "history",
    /**
     * The base URL of the app. For example, if the entire single page application is
     * served under `/app/`, then base should use the value `'/app/'`.
     *
     * This can be useful if you need to serve Nuxt as a different context root, from
     * within a bigger web site.
     */
    base: {
      $resolve: async (val, get) => val ? withTrailingSlash(normalizeURL(val)) : (await get("app")).baseURL
    },
    /**
     * @private
     */
    _routerBaseSpecified: {
      $resolve: async (_val, get) => typeof await get("router.base") === "string"
    },
    routes: [],
    /**
     * This allows changing the separator between route names that Nuxt uses.
     *
     * Imagine we have the page file `pages/posts/_id.vue`. Nuxt will generate the
     * route name programmatically, in this case `posts-id`. If you change the routeNameSplitter
     * config to `/` the name will change to `posts/id`.
     */
    routeNameSplitter: "-",
    /**
     * Set the default(s) middleware for every page of the application.
     */
    middleware: {
      $resolve: (val) => Array.isArray(val) ? val : [val].filter(Boolean)
    },
    /**
     * Globally configure `<nuxt-link>` default active class.
     */
    linkActiveClass: "nuxt-link-active",
    /**
     * Globally configure `<nuxt-link>` default exact active class.
     */
    linkExactActiveClass: "nuxt-link-exact-active",
    /**
     * Globally configure `<nuxt-link>` default prefetch class (feature disabled by default).
     */
    linkPrefetchedClass: false,
    /**
     * You can pass a function to extend the routes created by Nuxt.
     *
     * @example
     * ```js
     * import { fileURLToPath } from 'url'
     * export default {
     *   router: {
     *     extendRoutes(routes, resolve) {
     *       routes.push({
     *         name: 'custom',
     *         path: '*',
     *         component: fileURLToPath(new URL('./pages/404.vue', import.meta.url))
     *       })
     *     }
     *   }
     * }
     * ```
     */
    extendRoutes: null,
    /**
     * The `scrollBehavior` option lets you define a custom behavior for the scroll
     * position between the routes. This method is called every time a page is
     * rendered. To learn more about it, see the `vue-router` documentation.
     *
     * @see [vue-router `scrollBehavior` documentation](https://router.vuejs.org/guide/advanced/scroll-behavior.html).
     */
    scrollBehavior: {
      $schema: {
        deprecated: "router.scrollBehavior` property is deprecated in favor of using `~/app/router.scrollBehavior.js` file, learn more: https://nuxtjs.org/api/configuration-router#scrollbehavior"
      }
    },
    /**
     * Provide custom query string parse function. Overrides the default.
     */
    parseQuery: false,
    /**
     * Provide custom query string stringify function. Overrides the default.
     */
    stringifyQuery: false,
    /**
     * Controls whether the router should fall back to hash mode when the browser
     * does not support history.pushState, but mode is set to history.
     *
     * Setting this to `false` essentially makes every router-link navigation a full
     * page refresh in IE9. This is useful when the app is server-rendered and needs
     * to work in IE9, because a hash mode URL does not work with SSR.
     */
    fallback: false,
    /**
     * Configure `<nuxt-link>` to prefetch the code-splitted page when detected within
     * the viewport. Requires [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) to be supported (see [Caniuse](https://caniuse.com/intersectionobserver)).
     */
    prefetchLinks: true,
    /**
     * When using `nuxt generate` with target: 'static', Nuxt will generate a
     * payload.js for each page.
     *
     * With this option enabled, Nuxt will automatically prefetch the payload of the
     * linked page when the `<nuxt-link>` is visible in the viewport, making instant navigation.
     */
    prefetchPayloads: true,
    /**
     * If this option is set to `true`, trailing slashes will be appended to every
     * route. If set to `false`, they'll be removed.
     *
     * @warning This option should not be set without preparation and has to
     * be tested thoroughly. When setting `trailingSlash` to something else than
     * `undefined`, the opposite route will stop working. Thus, 301 redirects should
     * be in place and your internal linking has to be adapted correctly. If you set
     * `trailingSlash` to `true`, then only `example.com/abc/` will work, but not
     * `example.com/abc`. On `false`, it's vice-versa.
     */
    trailingSlash: void 0
  }
});

const server = defineUntypedSchema({
  server: {
    /**
     * Whether to enable HTTPS.
     *
     * @example
     * ```
     * import { fileURLToPath } from 'node:url'
     * export default {
     *   server: {
     *     https: {
     *       key: fs.readFileSync(fileURLToPath(new URL('./server.key', import.meta.url))),
     *       cert: fs.readFileSync(fileURLToPath(new URL('./server.crt', import.meta.url)))
     *     }
     *   }
     * }
     * ```
     * @type {false | { key: string; cert: string }}
     */
    https: false,
    port: process.env.NUXT_PORT || process.env.PORT || process.env.npm_package_config_nuxt_port || 3e3,
    host: process.env.NUXT_HOST || process.env.HOST || process.env.npm_package_config_nuxt_host || "localhost",
    socket: process.env.UNIX_SOCKET || process.env.npm_package_config_unix_socket,
    /**
     * Enabling timing adds a middleware to measure the time elapsed during
     * server-side rendering and adds it to the headers as 'Server-Timing'.
     *
     * Apart from true/false, this can be an object for providing options.
     * Currently, only `total` is supported (which directly tracks the whole
     * time spent on server-side rendering.
     */
    timing: (val) => val ? { total: true, ...val } : false
  }
});

const index = {
  ...app,
  ...build,
  ...cli,
  ...common,
  ...generate,
  ...messages,
  ...render,
  ...router,
  ...server
};

export { index as NuxtConfigSchema };
